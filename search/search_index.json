{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LIMIT Language","text":"<p>LIMIT is a minimalist programming language and transpiler designed as a DSL for extensibility and powerful programming for beginners. Whether you're building educational tools, exploring compiler theory, or designing custom interfaces, LIMIT offers a simple but expressive foundation.</p>"},{"location":"#why-limit","title":"Why LIMIT?","text":"<ul> <li>Clarity-first syntax \u2014 prefix-style expressions and block-scoped logic</li> <li>Customizable \u2014 remap tokens, build domain-specific interfaces</li> <li>Fast feedback loop \u2014 REPL and file execution</li> <li>Multi-target transpilation \u2014 currently supports Python; future targets: C, JavaScript, WASM, LLVM</li> <li>100% test coverage \u2014 all features covered by strict, reproducible test suites</li> </ul>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":"<ul> <li>Custom handwritten parser (no parser generators)</li> <li>Human-readable abstract syntax tree (AST)</li> <li>Function and class support with full control flow</li> <li>TRY/CATCH/FINALLY, modularity, import/export</li> <li>Transpiler system with pluggable emitters</li> <li>A REPL for interactive experimentation</li> <li>Built-in aliasing for symbolic or word-based syntax</li> </ul>"},{"location":"#explore-the-docs","title":"Explore the Docs","text":"<ul> <li>Quickstart \u2013 Get up and running fast</li> <li>Syntax Cheatsheet \u2013 Statements, expressions, and keywords</li> <li>REPL Usage \u2013 Try out LIMIT interactively</li> <li>API Reference \u2013 Dig into the internals</li> </ul>"},{"location":"#repository","title":"Repository","text":"<p>GitHub: https://github.com/codingEd-u/limit</p> <p>LIMIT is open source, extensible, and built for curious developers who want to understand what it really takes to build a language from scratch.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Get LIMIT up and running in minutes.</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12</li> <li>PDM (Python Development Manager)</li> </ul>"},{"location":"quickstart/#1-install-python-312","title":"1. Install Python 3.12","text":"<p>Download: https://www.python.org/downloads/</p> <p>When installing: - \u2611 Add to PATH - \u2611 Enable pip</p>"},{"location":"quickstart/#2-install-pdm","title":"2. Install PDM","text":"<pre><code>pip install -U pdm\n````\n\n---\n\n## 3. Clone the Repo\n\n```bash\ngit clone https://github.com/codingEd-u/limit.git\ncd limit\n</code></pre> <p>(Optional but recommended):</p> <pre><code>pdm use -f 3.12\n</code></pre>"},{"location":"quickstart/#4-install-dependencies","title":"4. Install Dependencies","text":"<pre><code>pdm install\n</code></pre> <p>This installs all dependencies defined in <code>pyproject.toml</code>.</p>"},{"location":"quickstart/#5-run-the-repl","title":"5. Run the REPL","text":"<pre><code>pdm run limit\n</code></pre> <p>Or explicitly:</p> <pre><code>pdm run python -m limit.limit_cli\n</code></pre>"},{"location":"quickstart/#6-run-a-limit-file","title":"6. Run a <code>.limit</code> File","text":"<p>Save your code as <code>hello.limit</code>:</p> <pre><code>@ main() {\n  = msg \"Hello, LIMIT!\"\n  ! msg\n}\nCALL main\n</code></pre> <p>Then run:</p> <pre><code>pdm run python -m limit.limit_cli hello.limit\n</code></pre>"},{"location":"quickstart/#7-run-the-tests-optional","title":"7. Run the Tests (Optional)","text":"<pre><code>pdm run test\n</code></pre>"},{"location":"quickstart/#8-view-the-docs-locally-optional","title":"8. View the Docs Locally (Optional)","text":"<pre><code>pdm run docs\n</code></pre> <p>Visit <code>http://127.0.0.1:8000/</code> to browse the docs.</p> <p>LIMIT is now ready to explore.</p> <p>```</p>"},{"location":"repl/","title":"REPL Usage Guide","text":"<p>The LIMIT REPL lets you write and test LIMIT code interactively with instant feedback. It's ideal for experimentation, debugging, and learning the language incrementally.</p>"},{"location":"repl/#launch-the-repl","title":"Launch the REPL","text":"<p>From your project directory, run:</p> <pre><code>pdm run limit\n</code></pre> <p>or:</p> <pre><code>pdm run python -m limit.limit_cli\n</code></pre> <p>You\u2019ll see:</p> <pre><code>LIMIT &gt; \n</code></pre> <p>This is your interactive prompt.</p>"},{"location":"repl/#writing-code-in-the-repl","title":"Writing Code in the REPL","text":"<p>You can enter full LIMIT statements or expressions directly.</p> <p>Examples:</p> <pre><code>= x 5\n! x\n</code></pre> <pre><code>@ square(n) {\n  RETURN [* n n]\n}\n! [CALL square 3]\n</code></pre>"},{"location":"repl/#supported-constructs","title":"Supported Constructs","text":"<p>Anything you can write in a <code>.limit</code> file works in the REPL:</p> <ul> <li>Assignments: <code>= x 10</code></li> <li>Function calls: <code>CALL foo</code></li> <li>Expressions: <code>[+ 1 2]</code></li> <li>Control flow: <code>? (== x 5) { ! \"ok\" } else { ! \"fail\" }</code></li> <li>Loops, classes, modules, try/catch, etc.</li> </ul>"},{"location":"repl/#expression-results","title":"Expression Results","text":"<p>If you enter a bare expression or function call inside brackets, the REPL will evaluate and print the result:</p> <pre><code>! [CALL sum 1 2]\n</code></pre> <p>If you enter an expression without <code>!</code>, it won\u2019t print unless returned from a function.</p>"},{"location":"repl/#errors-and-feedback","title":"Errors and Feedback","text":"<p>The REPL provides clear errors for:</p> <ul> <li>Syntax problems (<code>SyntaxError</code>)</li> <li>Runtime failures (<code>ZeroDivisionError</code>, <code>AttributeError</code>, etc.)</li> <li>Invalid token or unknown identifier</li> </ul> <p>Example:</p> <pre><code>= x [/ 1 0]\n</code></pre> <p>Outputs:</p> <pre><code>RuntimeError: division by zero\n</code></pre>"},{"location":"repl/#loading-limit-files","title":"Loading <code>.limit</code> Files","text":"<p>You can run a script file instead of typing manually:</p> <pre><code>pdm run python -m limit.limit_cli myscript.limit\n</code></pre> <p>This lets you build reusable programs and modules.</p>"},{"location":"repl/#advanced-testing","title":"Advanced Testing","text":"<p>You can test syntax, edge cases, and transpilation interactively:</p> <pre><code>CLASS A {\n  @ get(self) {\n    RETURN 42\n  }\n}\n= a NEW A()\n! CALL a.get()\n</code></pre>"},{"location":"repl/#exiting","title":"Exiting","text":"<p>To exit the REPL, press:</p> <pre><code>Ctrl + C   # interrupt current line\nCtrl + D   # exit REPL completely\n</code></pre>"},{"location":"repl/#tips","title":"Tips","text":"<ul> <li>Use <code>SKIP</code> to safely define placeholder methods or functions.</li> <li>Use <code>PRINT</code> (<code>!</code>) for debugging or observing expressions.</li> <li>You can alias symbols using <code>SUGAR</code> inside the REPL too.</li> </ul> <p>Explore the Syntax Cheatsheet for more constructs.</p> <p>```</p>"},{"location":"syntax/","title":"Syntax Cheatsheet","text":"<p>This is the canonical token mapping for the LIMIT programming language, with examples after every group. Each token maps to a normalized internal parser type.</p>"},{"location":"syntax/#control-structures","title":"Control Structures","text":"Symbol Token <code>?</code> <code>IF</code> <code>else</code> <code>ELSE</code> <code>=</code> <code>ASSIGN</code> <code>!</code> <code>PRINT</code> <code>WHILE</code> <code>LOOP_WHILE</code> <code>FOR</code> <code>LOOP_FOR</code> <code>BREAK</code> <code>BREAK</code> <code>CONTINUE</code> <code>CONTINUE</code> <p>Examples:</p> <pre><code>? (&gt; x 10) { ! \"Too big\" } else { ! \"OK\" }\n\n= count 0\n\nWHILE [&lt; count 3] {\n  ! count\n  = count [+ count 1]\n}\n\nFOR i TO 3 {\n  ! i\n}\n\nBREAK\nCONTINUE\n</code></pre>"},{"location":"syntax/#function-invocation","title":"Function &amp; Invocation","text":"Symbol Token <code>@</code> <code>FUNC</code> <code>CALL</code> <code>CALL</code> <code>RETURN</code> <code>RETURN</code> <code>SKIP</code> <code>SKIP</code> <p>Examples:</p> <pre><code>@ add(x, y) {\n  RETURN [+ x y]\n}\n\n! [CALL add 1 2]\n\n@ doNothing() {\n  SKIP\n}\n</code></pre>"},{"location":"syntax/#input-output","title":"Input &amp; Output","text":"Symbol Token <code>INPUT</code> <code>INPUT</code> <code>FROM</code> <code>DELIM_FROM</code> <p>Examples:</p> <pre><code>INPUT name\nINPUT age: int\nINPUT score: float\nINPUT FROM \"data.txt\"\n</code></pre>"},{"location":"syntax/#error-handling","title":"Error Handling","text":"Symbol Token <code>TRY</code> <code>TRY</code> <code>CATCH</code> <code>CATCH</code> <code>FINALLY</code> <code>FINALLY</code> <p>Examples:</p> <pre><code>TRY {\n  = x [/ 1 0]\n} CATCH {\n  ! \"Error\"\n} FINALLY {\n  ! \"Cleanup\"\n}\n</code></pre>"},{"location":"syntax/#classes-objects","title":"Classes &amp; Objects","text":"Symbol Token <code>CLASS</code> <code>CLASS</code> <code>EXTENDS</code> <code>EXTENDS</code> <code>NEW</code> <code>NEW</code> <code>THIS</code> <code>THIS</code> <p>Examples:</p> <pre><code>CLASS Point {\n  @ init(self, x, y) {\n    = self.x x\n    = self.y y\n  }\n}\n\n= p NEW Point(1, 2)\n! p.x\n</code></pre>"},{"location":"syntax/#modules","title":"Modules","text":"Symbol Token <code>MODULE</code> <code>MODULE</code> <code>IMPORT</code> <code>IMPORT</code> <code>EXPORT</code> <code>EXPORT</code> <p>Examples:</p> <pre><code>MODULE mymod\nIMPORT \"file.limit\"\n\n@ foo() {\n  RETURN 1\n}\nEXPORT foo\n</code></pre>"},{"location":"syntax/#propagation","title":"Propagation","text":"Symbol Token <code>$</code> <code>PROP</code> <p>Examples:</p> <pre><code>@ maybe(x) {\n  $ x\n  RETURN 0\n}\nCALL maybe(42)\n</code></pre>"},{"location":"syntax/#literals","title":"Literals","text":"Symbol Token <code>TRUE</code> <code>LITERAL</code> <code>FALSE</code> <code>LITERAL</code> <code>NULL</code> <code>LITERAL</code> <p>Examples:</p> <pre><code>= flag TRUE\n= nope FALSE\n= x NULL\n</code></pre>"},{"location":"syntax/#prefix-operators","title":"Prefix Operators","text":"Symbol(s) Token <code>+</code> <code>PLUS</code> <code>-</code> <code>SUB</code> <code>*</code> <code>MULT</code> <code>/</code> <code>DIV</code> <code>%</code> <code>MOD</code> <code>==</code>, <code>EQ</code> <code>EQ</code> <code>!=</code>, <code>NE</code> <code>NE</code> <code>&lt;</code> <code>LT</code> <code>&gt;</code> <code>GT</code> <code>&lt;=</code> <code>LE</code> <code>&gt;=</code> <code>GE</code> <code>AND</code> <code>AND</code> <code>OR</code> <code>OR</code> <code>NOT</code> <code>NOT</code> <p>Examples:</p> <pre><code>[+ 1 2]\n[* 3 4]\n[== a b]\n[AND TRUE FALSE]\n[NOT TRUE]\n</code></pre>"},{"location":"syntax/#symbols-delimiters","title":"Symbols &amp; Delimiters","text":"Symbol Token <code>(</code> <code>)</code> <code>LPAREN</code>, <code>RPAREN</code> <code>[</code> <code>]</code> <code>LBRACK</code>, <code>RBRACK</code> <code>{</code> <code>}</code> <code>LBRACE</code>, <code>RBRACE</code> <code>.</code> <code>DOT</code> <code>:</code> <code>COLON</code> <code>,</code> <code>COMMA</code> <p>Examples:</p> <pre><code>! [CALL sum(1, 2)]\n= obj.field\n@ f(x: int) { ! x }\n</code></pre>"},{"location":"syntax/#for-loop-enhancements","title":"FOR Loop Enhancements","text":"Symbol Token <code>TO</code> <code>DELIM_TO</code> <code>AT</code> <code>DELIM_AT</code> <code>BY</code> <code>DELIM_BY</code> <p>Examples:</p> <pre><code>FOR i TO 3 {\n  ! i\n}\n\nFOR j AT 1 TO 5 {\n  ! j\n}\n\nFOR k AT 10 TO 0 BY -2 {\n  ! k\n}\n</code></pre>"},{"location":"syntax/#types-identifiers","title":"Types &amp; Identifiers","text":"Value Token <code>\"text\"</code> <code>STRING</code> <code>42</code> <code>NUMBER</code> <code>3.14</code> <code>FLOAT</code> <code>my_var</code>, <code>caf\u00e9</code> <code>IDENT</code> (Unicode supported) <p>Examples:</p> <pre><code>= name \"Alice\"\n= age 42\n= pi 3.14\n= caf\u00e9 \"cr\u00e8me br\u00fbl\u00e9e\"\n</code></pre>"},{"location":"syntax/#sugar-mapping-aliases","title":"Sugar Mapping (Aliases)","text":"<p>LIMIT allows alternate names for tokens using <code>SUGAR</code> blocks.</p> <p>Examples:</p> <pre><code>SUGAR {\n  [\"add\", \"sum\", \"plus\"]: \"PLUS\"\n}\nSUGAR {\n  [\"increase\", \"inc\"]: \"PLUS\"\n}\n</code></pre> <p>Use these to customize the language surface for a domain-specific use case or natural-language style.</p> <p>Want to try these live? Jump to the REPL Usage Guide.</p> <p>```</p>"},{"location":"api/limit_ast/","title":"AST","text":"<p>Defines the abstract syntax tree (AST) node structure for the LIMIT programming language.</p> <p>Classes:</p> Name Description <code>ASTNode</code> <p>Represents a node in the syntax tree, used by the parser, emitter, and transpiler. Supports recursion, type annotations, and metadata for error reporting and transpilation.</p> <code>ASTDict</code> <p>TypedDict representation for serializing ASTNode instances to plain Python dictionaries, suitable for JSON output or debugging.</p> Each ASTNode tracks <p>kind (str): The syntactic construct type (e.g., \"func\", \"if\", \"call\"). value (Union[str, ASTNode], optional): A raw string or another ASTNode. children (list[ASTNode]): Primary child nodes. else_children (list[ASTNode]): Used for else/catch/finally blocks. type (str, optional): Type annotation for declarations or inputs. return_type (str, optional): Return type for functions. line (int): Source line number for error messages. col (int): Source column number for error messages.</p> Usage <p>This module serves as the core data structure for LIMIT\u2019s parser output. It is also used by the emitter for code generation and by test suites for asserting structure.</p> Example <p>node = ASTNode(\"func\", value=\"main\", children=[...], type_=\"int\", return_type=\"str\")</p>"},{"location":"api/limit_ast/#limit.limit_ast.ASTDict","title":"<code>ASTDict</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict representation of an ASTNode used for serialization.</p> <p>This structure defines the shape of a serialized abstract syntax tree (AST) node, typically used when converting an ASTNode to a dictionary (e.g., for JSON output, debugging, or inspection).</p> Fields <p>kind (str): The type of AST node (e.g., \"func\", \"call\", \"if\"). value (Any): The node's value, which may be a string, nested ASTDict, or literal. line (int): Line number in the source code where the node originates. col (int): Column number in the source code where the node originates. type (Optional[str]): Optional type annotation (e.g., for variables or inputs). return_type (Optional[str]): Optional return type annotation (e.g., for functions). children (List[ASTDict]): Primary child nodes in the AST hierarchy. else_children (List[ASTDict]): Alternate branch nodes (e.g., for 'else', 'catch').</p>"},{"location":"api/limit_ast/#limit.limit_ast.ASTNode","title":"<code>ASTNode(kind, value=None, children=None, line=0, col=0, type_=None, return_type=None)</code>","text":"<p>Represents a node in the abstract syntax tree (AST) for the LIMIT language.</p> <p>Each node captures a syntactic construct such as a function, expression, loop, or class. Nodes are recursively structured and support conversion to dictionary form for serialization.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>The type of node (e.g., \"func\", \"call\", \"assign\", \"if\").</p> required <code>value</code> <code>Union[str, ASTNode]</code> <p>A literal value or another AST node (e.g., function name or callee).</p> <code>None</code> <code>children</code> <code>list[ASTNode]</code> <p>Primary child nodes in the syntax tree.</p> <code>None</code> <code>line</code> <code>int</code> <p>Source line number (default is 0).</p> <code>0</code> <code>col</code> <code>int</code> <p>Source column number (default is 0).</p> <code>0</code> <code>type_</code> <code>str</code> <p>Optional type annotation (e.g., input type or variable type).</p> <code>None</code> <code>return_type</code> <code>str</code> <p>Optional return type (e.g., for functions or methods).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>kind</code> <code>str</code> <p>Type of the AST node.</p> <code>value</code> <code>Union[str, ASTNode] | None</code> <p>Value or nested node.</p> <code>children</code> <code>list[ASTNode]</code> <p>Main child nodes.</p> <code>else_children</code> <code>list[ASTNode]</code> <p>Alternate path nodes (e.g., else or catch blocks).</p> <code>type</code> <code>str | None</code> <p>Type annotation.</p> <code>return_type</code> <code>str | None</code> <p>Return type annotation.</p> <code>line</code> <code>int</code> <p>Line number in the source file.</p> <code>col</code> <code>int</code> <p>Column number in the source file.</p> <code>_in_class</code> <code>bool | None</code> <p>Internal flag indicating if the node was declared inside a class.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Returns a structured string representation for debugging.</p> <code>__eq__</code> <p>Checks structural equality with another ASTNode.</p> <code>to_dict</code> <p>Converts the node (and all descendants) into a nested dictionary format.</p> Source code in <code>src/limit/limit_ast.py</code> <pre><code>def __init__(\n    self,\n    kind: str,\n    value: Union[str, \"ASTNode\"] | None = None,\n    children: list[\"ASTNode\"] | None = None,\n    line: int = 0,\n    col: int = 0,\n    type_: str | None = None,\n    return_type: str | None = None,\n):\n    self.kind = kind\n    self.value = value\n    self.children: list[\"ASTNode\"] = children or []\n    self.line = line\n    self.col = col\n    self.type = type_\n    self.return_type = return_type\n    self.else_children: list[\"ASTNode\"] = []\n    self._in_class: bool | None = None\n</code></pre>"},{"location":"api/limit_cli/","title":"CLI","text":"<p>LIMIT CLI Entrypoint.</p> <p>This module provides the command-line interface for executing LIMIT source code. It supports transpilation, execution, and interactive REPL mode.</p> Features <ul> <li>Read source from <code>.limit</code> files or inline strings.</li> <li>Lex, parse, and transpile code into the selected target language.</li> <li>Output to console or file.</li> <li>Optionally execute transpiled Python code.</li> <li>Launch an interactive REPL with optional verbosity.</li> </ul> Example usage <p>limit hello.limit limit -s \"PRINT 123\" -e limit myfile.limit -t py -o myfile.py limit --repl --verbose</p> <p>Functions:</p> Name Description <code>run_limit</code> <p>str, is_string: bool = False, target: str = \"py\", out: Optional[str] = None,       execute: bool = False, pretty: bool = False) -&gt; None: Executes the full LIMIT pipeline (lex \u2192 parse \u2192 transpile \u2192 output/exec).</p> <code>main</code> <p>Parses CLI arguments and invokes the appropriate action (REPL, transpile, or execute).</p>"},{"location":"api/limit_cli/#limit.limit_cli.main","title":"<code>main()</code>","text":"<p>Entry point for the LIMIT CLI.</p> <p>Parses command-line arguments and dispatches to the appropriate mode: - Launches the REPL if no arguments are passed or <code>--repl</code> is specified. - Otherwise, runs the full LIMIT toolchain (lex \u2192 parse \u2192 transpile \u2192 output/exec).</p> Supported flags <ul> <li><code>-s</code>, <code>--string</code>: Interpret source as a raw string instead of a file path.</li> <li><code>-t</code>, <code>--target</code>: Transpilation target ('py' or 'c'), default is 'py'.</li> <li><code>-o</code>, <code>--out</code>: Write transpiled output to a file.</li> <li><code>-e</code>, <code>--exec</code>: Execute the transpiled Python code.</li> <li><code>-p</code>, <code>--pretty</code>: Show pretty-printed banners and output sections.</li> <li><code>--repl</code>: Launch the interactive REPL.</li> <li><code>--verbose</code>: Enable verbose REPL mode.</li> </ul> <p>This function is called automatically when the script is executed as a standalone program.</p> Source code in <code>src/limit/limit_cli.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Entry point for the LIMIT CLI.\n\n    Parses command-line arguments and dispatches to the appropriate mode:\n    - Launches the REPL if no arguments are passed or `--repl` is specified.\n    - Otherwise, runs the full LIMIT toolchain (lex \u2192 parse \u2192 transpile \u2192 output/exec).\n\n    Supported flags:\n        - `-s`, `--string`: Interpret source as a raw string instead of a file path.\n        - `-t`, `--target`: Transpilation target ('py' or 'c'), default is 'py'.\n        - `-o`, `--out`: Write transpiled output to a file.\n        - `-e`, `--exec`: Execute the transpiled Python code.\n        - `-p`, `--pretty`: Show pretty-printed banners and output sections.\n        - `--repl`: Launch the interactive REPL.\n        - `--verbose`: Enable verbose REPL mode.\n\n    This function is called automatically when the script is executed as a standalone program.\n    \"\"\"\n    if len(sys.argv) == 1:\n        # No args passed: open REPL instead\n        from limit.limit_repl import start_repl\n\n        start_repl()\n        return\n    parser = argparse.ArgumentParser(prog=\"limit\")\n    parser.add_argument(\"source\", nargs=\"?\", help=\"Filename or raw source (with -s)\")\n    parser.add_argument(\n        \"-s\", \"--string\", action=\"store_true\", help=\"Interpret source as literal string\"\n    )\n    parser.add_argument(\n        \"-t\",\n        \"--target\",\n        choices=(\"py\", \"c\"),\n        default=\"py\",\n        help=\"Transpile target (default: py)\",\n    )\n    parser.add_argument(\"-o\", \"--out\", metavar=\"OUTFILE\", help=\"Output to file\")\n    parser.add_argument(\n        \"-e\",\n        \"--exec\",\n        dest=\"execute\",\n        action=\"store_true\",\n        help=\"Exec transpiled Python code\",\n    )\n    parser.add_argument(\n        \"-p\", \"--pretty\", action=\"store_true\", help=\"Show code/output with banners\"\n    )\n    parser.add_argument(\n        \"--repl\",\n        action=\"store_true\",\n        help=\"Launch interactive REPL instead of transpiling\",\n    )\n    parser.add_argument(\n        \"--verbose\", action=\"store_true\", help=\"Verbose REPL mode (if --repl)\"\n    )\n\n    args = parser.parse_args()\n\n    if args.repl or args.source is None:\n        from limit.limit_repl import start_repl\n\n        start_repl(target=args.target, verbose=args.verbose)\n    else:\n        run_limit(\n            source=args.source,\n            is_string=args.string,\n            target=args.target,\n            out=args.out,\n            execute=args.execute,\n            pretty=args.pretty,\n        )\n</code></pre>"},{"location":"api/limit_cli/#limit.limit_cli.run_limit","title":"<code>run_limit(source, is_string=False, target='py', out=None, execute=False, pretty=False)</code>","text":"<p>Run the LIMIT toolchain: lex, parse, transpile, and optionally execute or write output.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The LIMIT source code or path to a <code>.limit</code> file.</p> required <code>is_string</code> <code>bool</code> <p>If True, treats <code>source</code> as raw code instead of a file path. Defaults to False.</p> <code>False</code> <code>target</code> <code>str</code> <p>Transpilation target language ('py' or 'c'). Defaults to 'py'.</p> <code>'py'</code> <code>out</code> <code>str | None</code> <p>Optional path to write the transpiled output. If None, prints to stdout.</p> <code>None</code> <code>execute</code> <code>bool</code> <p>If True, executes the transpiled code (only valid for Python target). Defaults to False.</p> <code>False</code> <code>pretty</code> <code>bool</code> <p>If True, prints formatted banners and structured output. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>is_string</code> is False and the source does not end with '.limit'.</p> Side Effects <ul> <li>May write transpiled output to a file.</li> <li>May execute Python code in the current global context.</li> <li>Prints results or errors to stdout/stderr.</li> </ul> Source code in <code>src/limit/limit_cli.py</code> <pre><code>def run_limit(\n    source: str,\n    is_string: bool = False,\n    target: str = \"py\",\n    out: str | None = None,\n    execute: bool = False,\n    pretty: bool = False,\n) -&gt; None:\n    \"\"\"\n    Run the LIMIT toolchain: lex, parse, transpile, and optionally execute or write output.\n\n    Args:\n        source (str): The LIMIT source code or path to a `.limit` file.\n        is_string (bool): If True, treats `source` as raw code instead of a file path. Defaults to False.\n        target (str): Transpilation target language ('py' or 'c'). Defaults to 'py'.\n        out (str | None): Optional path to write the transpiled output. If None, prints to stdout.\n        execute (bool): If True, executes the transpiled code (only valid for Python target). Defaults to False.\n        pretty (bool): If True, prints formatted banners and structured output. Defaults to False.\n\n    Raises:\n        ValueError: If `is_string` is False and the source does not end with '.limit'.\n\n    Side Effects:\n        - May write transpiled output to a file.\n        - May execute Python code in the current global context.\n        - Prints results or errors to stdout/stderr.\n    \"\"\"\n    if not is_string and not source.endswith(\".limit\"):\n        raise ValueError(\"Only .limit files are supported.\")\n    # 1. Read source\n    if not is_string:\n        with open(source, encoding=\"utf-8\") as f:\n            source = f.read()\n\n    # 2. Lexing\n    cs = CharacterStream(source, 0, 1, 1)\n    lexer = Lexer(cs)\n    tokens = []\n    while True:\n        tok = lexer.next_token()\n        if tok.type == \"EOF\":\n            break\n        tokens.append(tok)\n\n    # 3. Parsing\n    ast = Parser(tokens).parse()\n\n    # 4. Transpiling\n    transpiler = Transpiler(target)\n    code = transpiler.transpile(ast)\n\n    # 5. Output result\n    if pretty and target == \"py\":\n        banner = \"=\" * 20\n        print(f\"{banner}\\nTranspiled Python\\n{banner}\\n{code}\\n{banner}\\n\")\n    elif not out:\n        print(code)\n    else:\n        pass  # pragma: no cover\n\n    # 6. Optional write to file\n    if out:\n        with open(out, \"w\", encoding=\"utf-8\") as f:\n            f.write(code)\n        if pretty:\n            print(f\"(wrote to {out})\")\n        else:\n            pass  # pragma: no cover\n\n    # 7. Optional execution\n    if execute and target == \"py\":\n        buf = io.StringIO()\n        old_stdout = sys.stdout\n        try:\n            sys.stdout = buf\n            exec(code, globals(), locals())  # nosec B102\n        finally:\n            sys.stdout = old_stdout\n        if pretty:\n            print(\"&lt;&lt;&lt; OUTPUT &gt;&gt;&gt;\")\n        print(buf.getvalue().rstrip())\n    elif execute:\n        print(f\"Execution not supported for target: {target}\", file=sys.stderr)\n</code></pre>"},{"location":"api/limit_constants/","title":"Constants","text":"<p>Defines the canonical token vocabulary and token mappings for the LIMIT language.</p> Contents <ol> <li> <p>CANONICAL_TOKENS:</p> <ul> <li>Ordered list of all valid tokens in LIMIT.</li> <li>Includes operators, keywords, literals, delimiters, and primitives.</li> <li>Used by the lexer, parser, emitter, and UI alias mapper.</li> </ul> </li> <li> <p>CANONICAL_TOKEN_MAP:</p> <ul> <li>Maps human-readable symbolic names (e.g., 'ADDITION', 'WHILE_LOOP') to canonical token strings.</li> <li>Used for alias resolution, introspection, and external sugar configuration.</li> </ul> </li> <li> <p>operator_tokens:</p> <ul> <li>Indexed operator map used by the parser to normalize arithmetic, logical, and comparison tokens.</li> </ul> </li> <li> <p>token_hashmap:</p> <ul> <li>Maps raw input strings (like '+', '==', 'RETURN') to canonical tokens.</li> <li>Used by the lexer for longest-match recognition and token normalization.</li> </ul> </li> <li> <p>CONTROL_SYMBOLS:</p> <ul> <li>Subset of CANONICAL_TOKENS representing all valid control structures.</li> <li>Used by UI mappers and token validators.</li> </ul> </li> <li> <p>Token Categories and Constants:</p> <ul> <li>Includes EOF, IDENT, ERROR, NUMBER, STRING, LITERAL.</li> <li>Also defines character groups (e.g., WHITESPACE_CHARS, QUOTE_CHARS) and delimiter tokens.</li> </ul> </li> </ol> Usage <p>These definitions are the single source of truth for all token-based logic in LIMIT. Any addition to language syntax must first be reflected in this module to ensure consistency.</p> Used by <ul> <li>Lexer (<code>token_hashmap</code>, <code>CANONICAL_TOKENS</code>)</li> <li>Parser (<code>operator_tokens</code>, <code>CONTROL_SYMBOLS</code>)</li> <li>REPL alias engine (<code>CANONICAL_TOKEN_MAP</code>)</li> <li>Transpilers and emitters (via token normalization)</li> </ul>"},{"location":"api/limit_lexer/","title":"Lexer","text":"<p>Lexical analyzer for the LIMIT programming language.</p> <p>This module provides core components for converting raw source code into token streams:</p> <p>Classes:</p> Name Description <code>CharacterStream</code> <p>Stream abstraction for reading characters with line/column tracking.</p> <code>Token</code> <p>Represents a single token with type, value, and source location.</p> <code>Lexer</code> <p>Converts a CharacterStream into a sequence of tokens.</p> Features <ul> <li>Skips whitespace and single-line comments (<code>#</code>)</li> <li>Supports longest-match recognition of operators and keywords</li> <li>Recognizes:<ul> <li>Identifiers and keywords</li> <li>Numbers (integer and float)</li> <li>Strings (with escape sequences)</li> <li>Operators and punctuation</li> </ul> </li> </ul> <p>Raises:</p> Type Description <code>SyntaxError</code> <p>If invalid floats or unterminated strings are encountered.</p> Example <p>stream = CharacterStream(\"PRINT 42\") lexer = Lexer(stream) token = lexer.next_token() print(token) Token(PRINT, PRINT)</p> Exports <ul> <li>CharacterStream</li> <li>Token</li> <li>Lexer</li> <li>token_hashmap</li> </ul>"},{"location":"api/limit_lexer/#limit.limit_lexer.CharacterStream","title":"<code>CharacterStream(source, position=0, line=1, column=1)</code>","text":"<p>A utility for reading characters from a string source with line and column tracking.</p> <p>This stream is used by the LIMIT lexer to support character-by-character parsing with precise source location metadata for error reporting.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>The input source string.</p> <code>position</code> <code>int</code> <p>Current index in the source.</p> <code>line</code> <code>int</code> <p>Current line number (1-indexed).</p> <code>column</code> <code>int</code> <p>Current column number (1-indexed).</p> <p>Initializes the character stream.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The input source code.</p> required <code>position</code> <code>int</code> <p>Starting position index. Defaults to 0.</p> <code>0</code> <code>line</code> <code>int</code> <p>Starting line number. Defaults to 1.</p> <code>1</code> <code>column</code> <code>int</code> <p>Starting column number. Defaults to 1.</p> <code>1</code> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def __init__(self, source: str, position: int = 0, line: int = 1, column: int = 1):\n    \"\"\"\n    Initializes the character stream.\n\n    Args:\n        source (str): The input source code.\n        position (int, optional): Starting position index. Defaults to 0.\n        line (int, optional): Starting line number. Defaults to 1.\n        column (int, optional): Starting column number. Defaults to 1.\n    \"\"\"\n    self.source = source\n    self.position = position\n    self.line = line\n    self.column = column\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.CharacterStream.current","title":"<code>current()</code>","text":"<p>Returns the current character at the stream's position.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The current character, or None if the stream has reached EOF.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def current(self) -&gt; str | None:\n    \"\"\"Returns the current character at the stream's position.\n\n    Returns:\n        str | None: The current character, or None if the stream has reached EOF.\n    \"\"\"\n    return self.source[self.position] if self.position &lt; len(self.source) else None\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.CharacterStream.end_of_file","title":"<code>end_of_file()</code>","text":"<p>Checks if the stream has reached the end of the source input.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the stream has consumed all characters, False otherwise.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def end_of_file(self) -&gt; bool:\n    \"\"\"Checks if the stream has reached the end of the source input.\n\n    Returns:\n        bool: True if the stream has consumed all characters, False otherwise.\n    \"\"\"\n    return self.position &gt;= len(self.source)\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.CharacterStream.next","title":"<code>next()</code>","text":"<p>Consumes and returns the next character in the stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The next character.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If reading past the end of the source.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def next(self) -&gt; str:\n    \"\"\"\n    Consumes and returns the next character in the stream.\n\n    Returns:\n        str: The next character.\n\n    Raises:\n        Exception: If reading past the end of the source.\n    \"\"\"\n    if self.position &gt;= len(self.source):\n        raise Exception(\n            f\"CharacterStreamError: Attempted to read past end of source at position=&lt;{self.position}&gt;, line=&lt;{self.line}&gt;\"\n        )\n    char = self.source[self.position]\n    if char == \"\\n\":\n        self.line += 1\n        self.column = 1\n    else:\n        self.column += 1\n    self.position += 1\n    return char\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.CharacterStream.peek","title":"<code>peek(offset=0)</code>","text":"<p>Returns the character at the given offset from the current position without advancing.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Number of characters to look ahead. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The character at the offset, or an empty string if out of bounds.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def peek(self, offset: int = 0) -&gt; str:\n    \"\"\"\n    Returns the character at the given offset from the current position without advancing.\n\n    Args:\n        offset (int, optional): Number of characters to look ahead. Defaults to 0.\n\n    Returns:\n        str: The character at the offset, or an empty string if out of bounds.\n    \"\"\"\n    index = self.position + offset\n    if index &lt; 0 or index &gt;= len(self.source):\n        return \"\"\n    return self.source[index]\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer","title":"<code>Lexer(stream)</code>","text":"<p>Lexical analyzer for the LIMIT language.</p> <p>The Lexer takes a CharacterStream and converts it into a stream of Token objects. It supports identifiers, numbers, strings, operators, and comments.</p> <p>Attributes:</p> Name Type Description <code>stream</code> <code>CharacterStream</code> <p>The source stream to tokenize.</p> <p>Initializes the Lexer with a given character stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <code>CharacterStream</code> <p>The input character stream to lex.</p> required Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def __init__(self, stream: CharacterStream) -&gt; None:\n    \"\"\"Initializes the Lexer with a given character stream.\n\n    Args:\n        stream (CharacterStream): The input character stream to lex.\n    \"\"\"\n    self.stream = stream\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer.advance","title":"<code>advance()</code>","text":"<p>Consumes and returns the next character from the stream.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The next character.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def advance(self) -&gt; str:\n    \"\"\"Consumes and returns the next character from the stream.\n\n    Returns:\n        str: The next character.\n    \"\"\"\n    return self.stream.next()\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer.match_operator","title":"<code>match_operator()</code>","text":"<p>Attempts to match the longest valid operator from the current position.</p> <p>Returns:</p> Type Description <code>Token | None</code> <p>Token | None: A Token if a match is found, otherwise None.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def match_operator(self) -&gt; Token | None:\n    \"\"\"Attempts to match the longest valid operator from the current position.\n\n    Returns:\n        Token | None: A Token if a match is found, otherwise None.\n    \"\"\"\n    line, col = self.stream.line, self.stream.column\n    max_token = None\n    match_len = 0\n    candidate = \"\"\n\n    for i in range(32):  # reasonable cap\n        ch = self.stream.peek(i)\n        if ch == \"\":\n            break\n        candidate += ch\n        if candidate in token_hashmap:\n            max_token = candidate\n            match_len = i + 1\n\n    if max_token:\n        for _ in range(match_len):\n            self.advance()\n        return Token(token_hashmap[max_token], max_token, line, col)\n\n    return None\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer.next_token","title":"<code>next_token()</code>","text":"<p>Consumes and returns the next Token from the stream.</p> <p>Returns:</p> Name Type Description <code>Token</code> <code>Token</code> <p>The next token parsed from the stream.</p> <p>Raises:</p> Type Description <code>SyntaxError</code> <p>If a malformed token is encountered (e.g., unterminated string or malformed float).</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def next_token(self) -&gt; Token:\n    \"\"\"Consumes and returns the next Token from the stream.\n\n    Returns:\n        Token: The next token parsed from the stream.\n\n    Raises:\n        SyntaxError: If a malformed token is encountered (e.g., unterminated string or malformed float).\n    \"\"\"\n    if self.stream.end_of_file():\n        return Token(\"EOF\", \"EOF\", self.stream.line, self.stream.column)\n\n    self.skip_whitespace()\n\n    if self.stream.end_of_file():\n        return Token(\"EOF\", \"EOF\", self.stream.line, self.stream.column)\n\n    ch = self.peek()\n    line, col = self.stream.line, self.stream.column\n\n    # 1. Identifier or keyword\n    if ch.isalpha() or ch == \"_\":\n        ident = \"\"\n        while not self.stream.end_of_file() and (\n            self.peek().isalnum() or self.peek() == \"_\"\n        ):\n            ident += self.advance()\n        if ident in token_hashmap:\n            return Token(token_hashmap[ident], ident, line, col)\n        return Token(\"IDENT\", ident, line, col)\n\n    # 2. Number or float\n    if ch.isdigit():\n        num = \"\"\n        has_dot = False\n        while not self.stream.end_of_file() and (\n            self.peek().isdigit() or self.peek() == \".\"\n        ):\n            if self.peek() == \".\":\n                if has_dot:\n                    raise SyntaxError(\n                        f\"Invalid float format at line {line}, col {col}\"\n                    )\n                has_dot = True\n            num += self.advance()\n        return Token(\"FLOAT\" if has_dot else \"NUMBER\", num, line, col)\n\n    # 3. String\n    if ch in ('\"', \"'\"):\n        quote = self.advance()\n        val = \"\"\n        while not self.stream.end_of_file():\n            if self.peek() == \"\\\\\":\n                val += self.advance()\n                if not self.stream.end_of_file():\n                    val += self.advance()\n            elif self.peek() == quote:\n                break\n            else:\n                val += self.advance()\n        if self.peek() == quote:\n            self.advance()\n            return Token(\"STRING\", val, line, col)\n        raise SyntaxError(f\"Unterminated string at line {line}, col {col}\")\n\n    # 4. Compound or symbolic operator\n    token = self.match_operator()\n    if token:\n        return token\n\n    # 5. Unknown character \u2192 error\n    if not self.stream.end_of_file():\n        return Token(\"ERROR\", self.advance(), line, col)\n    else:\n        return Token(\"EOF\", \"EOF\", line, col)  # pragma: no cover\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer.peek","title":"<code>peek()</code>","text":"<p>Returns the next character in the stream without consuming it.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The upcoming character, or an empty string if EOF.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def peek(self) -&gt; str:\n    \"\"\"Returns the next character in the stream without consuming it.\n\n    Returns:\n        str: The upcoming character, or an empty string if EOF.\n    \"\"\"\n    return self.stream.peek()\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer.skip_comment","title":"<code>skip_comment()</code>","text":"<p>Advances through the stream until the end of a comment line.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def skip_comment(self) -&gt; None:\n    \"\"\"Advances through the stream until the end of a comment line.\"\"\"\n    while not self.stream.end_of_file() and self.peek() != \"\\n\":\n        self.advance()\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Lexer.skip_whitespace","title":"<code>skip_whitespace()</code>","text":"<p>Skips all whitespace and comments in the stream.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def skip_whitespace(self) -&gt; None:\n    \"\"\"Skips all whitespace and comments in the stream.\"\"\"\n    while not self.stream.end_of_file():\n        if self.peek() in \" \\t\\r\\n\":\n            self.advance()\n        elif self.peek() == \"#\":\n            self.skip_comment()\n        else:\n            break\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Token","title":"<code>Token(type_, value, line=0, col=0)</code>","text":"<p>Represents a single lexical token in the LIMIT language.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>The canonical token type (e.g. 'IDENT', 'NUMBER', 'EOF').</p> <code>value</code> <code>str</code> <p>The raw string value associated with the token.</p> <code>line</code> <code>int</code> <p>The 1-based line number where the token appears.</p> <code>col</code> <code>int</code> <p>The 1-based column number where the token starts.</p> <p>Initializes a new Token instance.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <code>str</code> <p>The token's type.</p> required <code>value</code> <code>str</code> <p>The literal value of the token.</p> required <code>line</code> <code>int</code> <p>The line number (default is 0).</p> <code>0</code> <code>col</code> <code>int</code> <p>The column number (default is 0).</p> <code>0</code> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def __init__(self, type_: str, value: str, line: int = 0, col: int = 0):\n    \"\"\"Initializes a new Token instance.\n\n    Args:\n        type_ (str): The token's type.\n        value (str): The literal value of the token.\n        line (int, optional): The line number (default is 0).\n        col (int, optional): The column number (default is 0).\n    \"\"\"\n    self.type = type_\n    self.value = value\n    self.line = line\n    self.col = col\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Token.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two Token instances for equality.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if equal, False otherwise.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Compares two Token instances for equality.\n\n    Args:\n        other (Any): The object to compare against.\n\n    Returns:\n        bool: True if equal, False otherwise.\n    \"\"\"\n    return (\n        isinstance(other, Token)\n        and self.type == other.type\n        and self.value == other.value\n        and self.line == other.line\n        and self.col == other.col\n    )\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Token.__hash__","title":"<code>__hash__()</code>","text":"<p>Computes the hash of the token for use in sets and dicts.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The token's hash value.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Computes the hash of the token for use in sets and dicts.\n\n    Returns:\n        int: The token's hash value.\n    \"\"\"\n    return hash((self.type, self.value, self.line, self.col))\n</code></pre>"},{"location":"api/limit_lexer/#limit.limit_lexer.Token.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the token.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A concise summary of the token's type and value.</p> Source code in <code>src/limit/limit_lexer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the token.\n\n    Returns:\n        str: A concise summary of the token's type and value.\n    \"\"\"\n    return f\"Token({self.type}, {self.value})\"\n</code></pre>"},{"location":"api/limit_parser/","title":"Parser","text":"<p>LIMIT Language Parser</p> <p>Parses LIMIT language source tokens into structured abstract syntax trees (ASTs).</p> <p>This module implements the core LIMIT parser logic, which transforms a flat list of lexer-generated <code>Token</code> objects into a validated tree of <code>ASTNode</code> instances. The parser fully supports the LIMIT language syntax, including nested expressions, block scoping, and control flow constructs. It serves as the backbone for all downstream analysis, transpilation, or interpretation.</p>"},{"location":"api/limit_parser/#limit.limit_parser--supported-constructs","title":"Supported Constructs","text":"<ul> <li> <p>Expressions:</p> <ul> <li>Prefix notation: <code>[PLUS x 1]</code>, <code>[CALL foo 1 2]</code></li> <li>Nested expressions with proper bracket handling</li> <li>Full operator support: arithmetic, boolean, comparison, member access, call, etc.</li> </ul> </li> <li> <p>Statements:</p> <ul> <li>Assignments: <code>= x 5</code>, <code>= obj.method(...)</code></li> <li>Control flow: <code>IF</code>, <code>WHILE</code>, <code>FOR</code>, <code>TRY</code>/<code>CATCH</code>/<code>FINALLY</code></li> <li>Functions: <code>FUNC name(...) { ... }</code> with optional return types</li> <li>Classes: <code>CLASS Foo EXTENDS Bar { ... }</code></li> <li>I/O: <code>INPUT</code>, <code>PRINT</code></li> <li>Modules: <code>MODULE</code>, <code>IMPORT</code>, <code>EXPORT</code></li> <li>Special: <code>SKIP</code>, <code>PROPAGATE</code>, <code>RETURN</code>, <code>BREAK</code>, <code>CONTINUE</code></li> </ul> </li> </ul>"},{"location":"api/limit_parser/#limit.limit_parser--parser-behavior","title":"Parser Behavior","text":"<ul> <li>Operates in strict mode by default: raises <code>SyntaxError</code> on invalid or malformed input.</li> <li>Performs multi-token lookahead and supports nested block structures.</li> <li>Supports both statement parsing and expression parsing via dedicated entry points.</li> <li>Expression parsing is exclusively prefix-based and requires square brackets <code>[]</code>.</li> </ul>"},{"location":"api/limit_parser/#limit.limit_parser--entry-points","title":"Entry Points","text":"<ul> <li><code>parse()</code>: Parse a full program into a list of top-level AST nodes.</li> <li><code>parse_expression()</code>: Parse a single prefix expression (must be bracketed).</li> <li><code>parse_statement()</code>: Parse a single statement (assignment, loop, control flow, etc.).</li> <li><code>parse_expr_entrypoint()</code>: Parse one-liner expressions or literals (REPL mode).</li> </ul>"},{"location":"api/limit_parser/#limit.limit_parser--returns","title":"Returns","text":"<p>list[ASTNode]     A list of parsed and validated ASTNode objects, representing the full abstract     syntax tree (AST) of the LIMIT program or subexpression.</p>"},{"location":"api/limit_parser/#limit.limit_parser--raises","title":"Raises","text":"<p>SyntaxError     Raised when malformed input is encountered, unexpected tokens appear,     or grammar rules are violated.</p>"},{"location":"api/limit_parser/#limit.limit_parser.Parser","title":"<code>Parser(tokens)</code>","text":"<p>LIMIT Parser Class</p> <p>Responsible for transforming a list of lexical tokens into structured abstract syntax trees (<code>ASTNode</code> objects) that represent a valid LIMIT program.</p> <p>This parser handles both top-level program structure and nested constructs such as function bodies, loop blocks, conditionals, and expressions. It supports full prefix-style expression parsing and enforces strict grammar rules unless explicitly configured otherwise.</p>"},{"location":"api/limit_parser/#limit.limit_parser.Parser--attributes","title":"Attributes","text":"<p>tokens : list[Token]     The input token stream to be parsed. position : int     Current index into the token stream. in_block : bool     Tracks whether the parser is currently inside a scoped block (e.g., function or loop). unary_ops : set[str]     Set of operator token types considered unary (e.g., NOT, TRUTHY). arith_ops : set[str]     Set of arithmetic operator token types (e.g., PLUS, SUB, MULT). bool_ops : set[str]     Set of boolean operator token types (e.g., AND, OR, NOT). comparison_ops : set[str]     Set of comparison operator token types (e.g., LT, EQ, GT). binary_ops : set[str]     Union of arithmetic, boolean, and comparison operators. prefix_ops : set[str]     All operator tokens allowed as the first token inside bracketed expressions. expression_ops : set[str]     All valid expression-start tokens, including CALL and PROP.</p>"},{"location":"api/limit_parser/#limit.limit_parser.Parser--methods","title":"Methods","text":"<p>parse() -&gt; list[ASTNode]     Parse a complete LIMIT program into an AST. parse_statement(strict: bool = True) -&gt; ASTNode     Parse a single LIMIT statement. parse_expression(strict: bool = True) -&gt; ASTNode     Parse a bracketed prefix expression. parse_expr_or_literal(strict: bool = True) -&gt; ASTNode     Parse a literal, identifier, or expression. parse_function(...) -&gt; ASTNode     Parse a function definition, including parameters and optional return type. parse_class(...) -&gt; ASTNode     Parse a class definition with optional inheritance. parse_block(...) -&gt; list[ASTNode]     Parse a <code>{}</code>-enclosed block of statements. parse_try(...) -&gt; ASTNode     Parse a <code>TRY</code>/<code>CATCH</code>/<code>FINALLY</code> block. parse_loop_while(...) -&gt; ASTNode     Parse a <code>WHILE</code> loop with optional bracketed condition. parse_loop_range(...) -&gt; ASTNode     Parse a <code>FOR</code> loop with <code>TO</code>, optional <code>AT</code> and <code>BY</code> range components. parse_assignment(...) -&gt; ASTNode     Parse an assignment statement. parse_call(...) -&gt; ASTNode     Parse a <code>CALL</code> expression or method call. parse_return(...) -&gt; ASTNode     Parse a <code>RETURN</code> statement with optional value. parse_input(...) -&gt; ASTNode     Parse an <code>INPUT</code> statement, optionally from file. parse_print(...) -&gt; ASTNode     Parse a <code>PRINT</code> statement. parse_export(...) -&gt; ASTNode     Parse an <code>EXPORT</code> declaration. parse_import(...) -&gt; ASTNode     Parse an <code>IMPORT</code> directive. parse_module(...) -&gt; ASTNode     Parse a <code>MODULE</code> declaration. parse_prefix_operator(...) -&gt; ASTNode     Parse a standalone prefix operator and its operands. parse_member_access(...) -&gt; ASTNode     Parse chained <code>.</code> access (e.g., <code>obj.x.y</code>). parse_propagate(...) -&gt; ASTNode     Parse a <code>PROPAGATE</code> (<code>$</code>) statement. parse_skip() -&gt; ASTNode     Parse a <code>SKIP</code> placeholder.</p>"},{"location":"api/limit_parser/#limit.limit_parser.Parser--raises","title":"Raises","text":"<p>SyntaxError     When an invalid construct or malformed syntax is encountered during parsing.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def __init__(self, tokens: list[Token]) -&gt; None:\n    self.tokens: list[Token] = tokens\n    self.position: int = 0\n    self.in_block: bool = False\n\n    # Aliases\n    PLUS = operator_tokens[0]\n    SUB = operator_tokens[1]\n    MULT = operator_tokens[2]\n    DIV = operator_tokens[3]\n    MOD = operator_tokens[4]\n\n    AND = operator_tokens[5]\n    OR = operator_tokens[6]\n    NOT = operator_tokens[7]\n    TRUTHY = operator_tokens[8]\n\n    LT = operator_tokens[9]\n    LE = operator_tokens[10]\n    GT = operator_tokens[11]\n    GE = operator_tokens[12]\n    EQ = operator_tokens[13]\n    NE = operator_tokens[14]\n\n    CALL = operator_tokens[15]\n    PROP = operator_tokens[16]\n\n    # TOKEN MAPPINGS (PARSER)\n\n    self.unary_ops: set[str] = {NOT, TRUTHY}\n\n    self.arith_ops: set[str] = {\n        PLUS,\n        SUB,\n        MULT,\n        DIV,\n        MOD,\n    }\n\n    self.bool_ops: set[str] = {AND, OR, NOT, TRUTHY}  # \u2705 Include TRUTHY\n\n    self.comparison_ops: set[str] = {\n        LT,\n        LE,\n        GT,\n        GE,\n        EQ,\n        NE,\n    }\n\n    self.binary_ops: set[str] = self.arith_ops | self.bool_ops | self.comparison_ops\n\n    # Build prefix_ops by collecting all keys in token_hashmap that map to known op types\n    canonical_ops = self.unary_ops | self.binary_ops\n    self.prefix_ops: set[str] = {\n        v for k, v in token_hashmap.items() if v in canonical_ops\n    }\n\n    self.expression_ops: set[str] = self.prefix_ops | {CALL, PROP}\n\n    self.CALL: str = CALL\n    self.PROP: str = PROP\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse","title":"<code>parse()</code>","text":"<p>Parse a full LIMIT program and return a list of top-level AST nodes.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse(self) -&gt; list[ASTNode]:\n    \"\"\"Parse a full LIMIT program and return a list of top-level AST nodes.\"\"\"\n    ast: list[ASTNode] = []\n    while self.current().type != \"EOF\":\n        pos_before = self.position\n        try:\n            node = self.parse_statement()\n            if node is not None:\n                ast.append(node)\n            elif self.position == pos_before and self.current().type != \"EOF\":\n                raise SyntaxError(\n                    f\"Unrecognized syntax near: {self.current().value}\"\n                )  # pragma: no cover\n        except SyntaxError as e:\n            raise e  # fail-fast\n    return ast\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_assignment","title":"<code>parse_assignment(strict=True)</code>","text":"<p>Parse a variable assignment with identifier and right-hand value.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_assignment(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a variable assignment with identifier and right-hand value.\"\"\"\n    assign_tok = self.match(\"ASSIGN\", strict=strict)\n    assert assign_tok is not None  # for mypy\n\n    # LEFT-HAND SIDE\n    if self.current().type == \"IDENT\":\n        name_node = self.parse_member_access()\n    else:\n        raise SyntaxError(f\"Invalid assignment target: {self.current()}\")\n\n    # RIGHT-HAND SIDE\n    if self.current().type == \"NEW\":\n        new_tok = self.match(\"NEW\", strict=strict)\n        assert new_tok is not None  # for mypy\n        class_tok = self.match(\"IDENT\", strict=strict)\n        assert class_tok is not None  # for mypy\n        args = []\n        if self.current().type == \"LPAREN\":\n            self.match(\"LPAREN\", strict=strict)\n            if self.current().type != \"RPAREN\":\n                while True:\n                    arg_tok = self.match(\n                        \"IDENT\",\n                        \"NUMBER\",\n                        \"FLOAT\",\n                        \"STRING\",\n                        \"LITERAL\",\n                        \"THIS\",\n                        strict=strict,\n                    )\n                    assert arg_tok is not None  # for mypy\n                    kind = (\n                        \"identifier\"\n                        if arg_tok.type in (\"IDENT\", \"THIS\")\n                        else arg_tok.type.lower()\n                    )\n                    args.append(\n                        ASTNode(\n                            kind, arg_tok.value, line=arg_tok.line, col=arg_tok.col\n                        )\n                    )\n                    if self.current().type == \"COMMA\":\n                        self.match(\"COMMA\", strict=strict)\n                    else:\n                        break\n            self.match(\"RPAREN\", strict=strict)\n        value_node = ASTNode(\n            \"new\",\n            class_tok.value,\n            children=args,\n            line=new_tok.line,\n            col=new_tok.col,\n        )\n\n    elif self.current().type == \"IDENT\" and self.peek().type == \"DOT\":\n        value_node = self.parse_member_access()\n\n    elif self.current().type == \"IDENT\" and self.peek().type == \"LPAREN\":\n        func_tok = self.match(\"IDENT\", strict=strict)\n        assert func_tok is not None  # for mypy\n        args = []\n        self.match(\"LPAREN\", strict=strict)\n        if self.current().type != \"RPAREN\":\n            while True:\n                arg_tok = self.match(\n                    \"IDENT\",\n                    \"NUMBER\",\n                    \"FLOAT\",\n                    \"STRING\",\n                    \"LITERAL\",\n                    \"THIS\",\n                    strict=strict,\n                )\n                assert arg_tok is not None  # for mypy\n                kind = (\n                    \"identifier\"\n                    if arg_tok.type in (\"IDENT\", \"THIS\")\n                    else arg_tok.type.lower()\n                )\n                args.append(\n                    ASTNode(kind, arg_tok.value, line=arg_tok.line, col=arg_tok.col)\n                )\n                if self.current().type == \"COMMA\":\n                    self.match(\"COMMA\", strict=strict)\n                else:\n                    break\n        self.match(\"RPAREN\", strict=strict)\n        value_node = ASTNode(\n            \"call\",\n            func_tok.value,\n            children=args,\n            line=func_tok.line,\n            col=func_tok.col,\n        )\n\n    elif self.current().type == \"LBRACK\":\n        value_node = self.parse_expression(strict=strict)\n        if value_node is None:\n            raise SyntaxError(\"Expected expression on right-hand side\")\n\n    elif self.current().type in (\n        \"NUMBER\",\n        \"FLOAT\",\n        \"STRING\",\n        \"LITERAL\",\n        \"IDENT\",\n        \"THIS\",\n    ):\n        value_tok = self.match(\n            \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"IDENT\", \"THIS\", strict=strict\n        )\n        if value_tok is None:\n            raise SyntaxError(\"Expected value on right-hand side\")\n        kind = (\n            \"identifier\"\n            if value_tok.type in (\"IDENT\", \"THIS\")\n            else value_tok.type.lower()\n        )\n        value_node = ASTNode(\n            kind, value_tok.value, line=value_tok.line, col=value_tok.col\n        )\n\n    else:\n        raise SyntaxError(\n            f\"Invalid right-hand side in assignment: {self.current()}\"\n        )\n\n    return ASTNode(\n        \"assign\",\n        value=name_node.value if name_node.kind == \"identifier\" else None,\n        children=[name_node, value_node],\n        line=assign_tok.line,\n        col=assign_tok.col,\n        type_=\"local\" if self.in_block else \"global\",\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_block","title":"<code>parse_block(open_type='LBRACE', strict=True)</code>","text":"<p>Parse a <code>{}</code>-enclosed scoped block of LIMIT statements.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_block(\n    self, open_type: str = \"LBRACE\", strict: bool = True\n) -&gt; list[ASTNode]:\n    \"\"\"Parse a `{}`-enclosed scoped block of LIMIT statements.\"\"\"\n    if open_type != \"LBRACE\":\n        raise SyntaxError(\n            f\"Invalid block delimiter: {open_type}. Blocks must use '{{' and '}}'.\"\n        )\n\n    expected_close = \"RBRACE\"\n    self.match(\"LBRACE\", strict=strict)\n\n    stmts = []\n    prev_in_block = self.in_block\n    self.in_block = True\n\n    if self.current().type == expected_close:\n        self.match(expected_close, strict=strict)\n        self.in_block = prev_in_block\n        return []\n\n    while self.current().type != expected_close:\n        if self.current().type == \"EOF\":\n            raise SyntaxError(\"Expected closing '}', got EOF\")\n\n        pos_before = self.position\n        stmt = self.parse_statement(strict=strict)\n        pos_after = self.position\n\n        if stmt is not None:\n            stmts.append(stmt)\n        elif pos_after == pos_before:\n            raise SyntaxError(\n                f\"Unrecognized statement inside block near: {self.current().value} (type={self.current().type})\"\n            )  # pragma: no cover\n\n    self.match(expected_close, strict=strict)\n    self.in_block = prev_in_block\n    return stmts\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_call","title":"<code>parse_call(strict=True)</code>","text":"<p>Parse a CALL expression with function or method syntax and arguments.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_call(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a CALL expression with function or method syntax and arguments.\"\"\"\n    call_tok = self.match(\"CALL\", strict=strict)\n    if call_tok is None:\n        raise SyntaxError(\"Expected 'CALL' keyword\")\n\n    # Handle method-style member access: CALL a.b(c, d)\n    if self.current().type == \"IDENT\":\n        if self.peek().type == \"DOT\":\n            callee = self.parse_member_access()\n        else:\n            ident_tok = self.match(\"IDENT\", strict=strict)\n            if ident_tok is None:\n                raise SyntaxError(\"Expected callee name after CALL\")\n            callee = ASTNode(\n                \"identifier\",\n                ident_tok.value,\n                line=ident_tok.line,\n                col=ident_tok.col,\n            )\n\n        args = []\n        if self.current().type == \"LPAREN\":\n            self.match(\"LPAREN\")\n            if self.current().type != \"RPAREN\":\n                while True:\n                    args.append(self.parse_expr_or_literal(strict=strict))\n                    if self.current().type == \"COMMA\":\n                        self.match(\"COMMA\")\n                    else:\n                        break\n            self.match(\"RPAREN\")\n        else:\n            while self.current().type in (\n                \"IDENT\",\n                \"NUMBER\",\n                \"FLOAT\",\n                \"STRING\",\n                \"LITERAL\",\n                \"THIS\",\n                \"LBRACK\",\n            ):\n                args.append(self.parse_expr_or_literal(strict=strict))\n\n        return ASTNode(\n            \"call\",\n            value=callee,\n            children=args,\n            line=call_tok.line,\n            col=call_tok.col,\n        )\n\n    raise SyntaxError(\"CALL must be followed by identifier or member access\")\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_class","title":"<code>parse_class(strict=True)</code>","text":"<p>Parse a CLASS definition with optional EXTENDS and class body.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_class(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a CLASS definition with optional EXTENDS and class body.\"\"\"\n    class_tok = self.match(\"CLASS\", strict=strict)\n    assert class_tok is not None  # for mypy\n    name_tok = self.match(\"IDENT\", strict=strict)\n    assert name_tok is not None  # for mypy\n\n    extends_node: ASTNode | None = None\n    if self.current().type == \"EXTENDS\":\n        self.match(\"EXTENDS\", strict=strict)\n        base_tok = self.match(\"IDENT\", strict=strict)\n        extends_node = ASTNode(\n            \"extends\", value=base_tok.value, line=base_tok.line, col=base_tok.col  # type: ignore\n        )\n\n    self.match(\"LBRACE\", strict=strict)\n    body: list[ASTNode] = []\n    while self.current().type != \"RBRACE\":\n        stmt = self.parse_statement(strict=strict)\n        if stmt is None:\n            raise SyntaxError(\"Invalid statement in class body\")\n        body.append(stmt)\n    self.match(\"RBRACE\", strict=strict)\n\n    children: list[ASTNode] = [extends_node] + body if extends_node else body\n    return ASTNode(\n        \"class\",\n        value=name_tok.value,\n        children=children,\n        line=name_tok.line,\n        col=name_tok.col,\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_export","title":"<code>parse_export(strict=True)</code>","text":"<p>Parse an EXPORT statement that exposes an identifier.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_export(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse an EXPORT statement that exposes an identifier.\"\"\"\n    tok = self.match(\"EXPORT\", \"IDENT\", strict=strict)\n    if tok is None:\n        raise SyntaxError(\"Expected 'EXPORT' keyword\")\n    assert tok is not None  # for mypy\n\n    name_tok = self.match(\"IDENT\", strict=strict)\n    if name_tok is None:\n        raise SyntaxError(\"Expected identifier after EXPORT\")\n    assert name_tok is not None  # for mypy\n\n    return ASTNode(\"export\", name_tok.value, line=tok.line, col=tok.col)\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_expr_entrypoint","title":"<code>parse_expr_entrypoint(strict=True)</code>","text":"<p>Parse a single top-level expression like <code>x</code> or <code>+ x 10</code>.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_expr_entrypoint(self, strict: bool = True) -&gt; list[ASTNode]:\n    \"\"\"Parse a single top-level expression like `x` or `+ x 10`.\"\"\"\n    if self.current().type in (\n        \"PLUS\",\n        \"SUB\",\n        \"MULT\",\n        \"DIV\",\n        \"MOD\",\n        \"AND\",\n        \"OR\",\n        \"NOT\",\n    ):\n        return [self.parse_prefix_operator(strict=strict)]\n\n    elif self.current().type == \"IDENT\":\n        ident_tok = self.match(\"IDENT\", strict=strict)\n        if ident_tok is None:\n            raise SyntaxError(\"Expected identifier\")\n        return [\n            ASTNode(\n                \"identifier\",\n                ident_tok.value,\n                line=ident_tok.line,\n                col=ident_tok.col,\n            )\n        ]\n\n    elif self.current().type in (\"NUMBER\", \"FLOAT\", \"STRING\"):\n        tok = self.match(self.current().type, strict=strict)\n        if tok is None:\n            raise SyntaxError(\"Expected literal value\")\n        return [ASTNode(tok.type.lower(), tok.value, line=tok.line, col=tok.col)]\n\n    else:\n        raise SyntaxError(f\"Unrecognized expression: {self.current()}\")\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_expr_or_literal","title":"<code>parse_expr_or_literal(strict=True)</code>","text":"<p>Parse either a bracketed expression or a single literal/identifier.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_expr_or_literal(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse either a bracketed expression or a single literal/identifier.\"\"\"\n    if self.current().type == \"LBRACK\":\n        expr = self.parse_expression(strict=strict)\n        return expr\n\n    if self.current().type == \"IDENT\" and self.peek().type == \"DOT\":\n        return self.parse_member_access()\n\n    tok = self.current()\n    if tok.type not in (\"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"THIS\"):\n        raise SyntaxError(f\"Expected expression or literal, got {tok}\")\n    tok = self.match(tok.type, strict=strict)  # type: ignore[assignment]\n    assert tok is not None  # for mypy\n\n    kind = \"identifier\" if tok.type in (\"IDENT\", \"THIS\") else tok.type.lower()\n    return ASTNode(kind, tok.value, line=tok.line, col=tok.col)\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_expression","title":"<code>parse_expression(strict=True)</code>","text":"<p>Parse a prefix-style bracketed expression like <code>[PLUS x 1]</code>.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_expression(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a prefix-style bracketed expression like `[PLUS x 1]`.\"\"\"\n    if self.current().type != \"LBRACK\":\n        if strict:\n            raise SyntaxError(\n                f\"Expected '[' to start expression, got {self.current()}\"\n            )\n        raise SyntaxError(\n            \"Non-strict mode no longer supports non-bracketed expression entry\"\n        )\n\n    open_tok = self.match(\"LBRACK\", strict=strict)\n    if open_tok is None:\n        raise SyntaxError(\"Expected '[' to open expression\")\n\n    close_type = \"RBRACK\"\n\n    if self.current().type == close_type:\n        self.match(close_type, strict=strict)\n        return ASTNode(\"empty\", None, line=open_tok.line, col=open_tok.col)\n\n    op_tok = self.match(*self.expression_ops, strict=strict)\n    if op_tok is None:\n        raise SyntaxError(\"Expected operator at start of expression\")\n\n    if op_tok.type == \"CALL\":\n        if self.current().type == \"IDENT\":\n            if self.peek().type == \"DOT\":\n                callee = self.parse_member_access(strict=strict)\n            else:\n                ident_tok = self.match(\"IDENT\", strict=strict)\n                if ident_tok is None:\n                    raise SyntaxError(\"Expected identifier after CALL\")\n                callee = ASTNode(\n                    \"identifier\",\n                    ident_tok.value,\n                    line=ident_tok.line,\n                    col=ident_tok.col,\n                )\n\n            if self.current().type == \"LPAREN\":\n                self.match(\"LPAREN\", strict=strict)\n                args = []\n                if self.current().type != \"RPAREN\":\n                    while True:\n                        args.append(self.parse_expr_or_literal(strict=strict))\n                        if self.current().type == \"COMMA\":\n                            self.match(\"COMMA\", strict=strict)\n                        else:\n                            break\n                self.match(\"RPAREN\", strict=strict)\n                self.match(close_type, strict=strict)\n                return ASTNode(\n                    \"call\",\n                    value=callee,\n                    children=args,\n                    line=op_tok.line,\n                    col=op_tok.col,\n                )\n\n            args = []\n            while self.current().type != close_type:\n                args.append(self.parse_expr_or_literal(strict=strict))\n\n            self.match(close_type, strict=strict)\n            return ASTNode(\n                \"call\",\n                value=callee,\n                children=args,\n                line=op_tok.line,\n                col=op_tok.col,\n            )\n\n        raise SyntaxError(\"CALL must be followed by identifier or member access\")\n\n    children: list[ASTNode] = []\n    while self.current().type != close_type:\n        if self.current().type == \"EOF\":\n            raise SyntaxError(\"Expected closing ']', got EOF\")\n\n        if self.current().type == \"COMMA\":\n            self.match(\"COMMA\", strict=strict)\n            continue\n\n        if self.current().type == \"LBRACK\":\n            child = self.parse_expression(strict=strict)\n        elif self.current().type == \"IDENT\" and self.peek().type == \"DOT\":\n            child = self.parse_member_access(strict=strict)\n        else:\n            tok = self.match(\n                \"NUMBER\",\n                \"FLOAT\",\n                \"STRING\",\n                \"LITERAL\",\n                \"IDENT\",\n                \"THIS\",\n                strict=strict,\n            )\n            if tok is None:\n                raise SyntaxError(\n                    f\"Unexpected token in expression: {self.current()}\"\n                )\n            kind = (\n                \"identifier\" if tok.type in (\"IDENT\", \"THIS\") else tok.type.lower()\n            )\n            child = ASTNode(kind, tok.value, line=tok.line, col=tok.col)\n\n        children.append(child)\n\n    self.match(close_type, strict=strict)\n\n    if op_tok.type in self.unary_ops and len(children) != 1:\n        raise SyntaxError(f\"{op_tok.type} requires 1 operand\")\n    elif op_tok.type not in self.unary_ops and len(children) &lt; 2:\n        raise SyntaxError(f\"{op_tok.type} requires at least 2 operands\")\n\n    if op_tok.type in self.arith_ops:\n        kind = \"arith\"\n    elif op_tok.type in self.bool_ops:\n        kind = \"bool\"\n    elif op_tok.type in self.comparison_ops:\n        kind = \"compare\"\n    elif op_tok.type == \"PROP\":\n        kind = \"propagate\"\n    else:\n        kind = \"unknown\"\n\n    return ASTNode(\n        kind,\n        value=op_tok.type,\n        line=op_tok.line,\n        col=op_tok.col,\n        children=children,\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_function","title":"<code>parse_function(strict=True)</code>","text":"<p>Parse a FUNC definition including parameters, return type, and body.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_function(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a FUNC definition including parameters, return type, and body.\"\"\"\n    func_tok = self.match(\"FUNC\", strict=strict)\n\n    name_tok = self.match(\"IDENT\", strict=strict)\n\n    self.match(\"LPAREN\", strict=strict)\n\n    params: list[str] = []\n    if self.current().type != \"RPAREN\":\n        while True:\n            param_tok = self.match(\"IDENT\", strict=strict)\n            params.append(param_tok.value)  # type: ignore\n\n            if self.current().type == \"COMMA\":\n                self.match(\"COMMA\", strict=strict)\n            else:\n                break\n\n    self.match(\"RPAREN\", strict=strict)\n\n    return_type: str | None = None\n    if self.current().type == \"COLON\":\n        self.match(\"COLON\", strict=strict)\n        rt_tok = self.match(\"IDENT\", strict=strict)\n        return_type = rt_tok.value  # type: ignore\n\n    if self.current().type != \"LBRACE\":\n        raise SyntaxError(\"Function body must start with '{'\")\n    block = self.parse_block(\"LBRACE\", strict=strict)\n\n    node = ASTNode(\"func\", value=name_tok.value, line=func_tok.line, col=func_tok.col, children=block)  # type: ignore\n    node.type = \",\".join(params) if params else None\n    node.return_type = return_type\n    return node\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_if","title":"<code>parse_if(strict=True)</code>","text":"<p>Parse an IF condition with optional ELSE block.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_if(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse an IF condition with optional ELSE block.\"\"\"\n    if_tok = self.match(\"IF\", strict=strict)\n    assert if_tok is not None  # for mypy\n\n    self.match(\"LPAREN\", strict=strict)\n\n    op_tok = self.current()\n    if op_tok.type not in self.prefix_ops:\n        raise SyntaxError(f\"Invalid IF operator: {op_tok}\")\n    op_tok = self.match_type_only(op_tok.type)\n    assert op_tok is not None  # for mypy\n\n    children: list[ASTNode] = []\n    while self.current().type != \"RPAREN\":\n        if self.current().type == \"EOF\":\n            raise SyntaxError(\"Unexpected EOF in IF condition\")\n\n        tok = self.match(\n            \"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"THIS\", strict=strict\n        )\n        if tok is None:\n            raise SyntaxError(\"Expected token in IF condition\")\n        kind = \"identifier\" if tok.type in (\"IDENT\", \"THIS\") else tok.type.lower()\n        children.append(ASTNode(kind, tok.value, line=tok.line, col=tok.col))\n    self.match(\"RPAREN\", strict=strict)\n\n    if op_tok.type in self.unary_ops and len(children) != 1:\n        raise SyntaxError(f\"{op_tok.type} requires 1 operand\")\n    elif op_tok.type not in self.unary_ops and len(children) &lt; 2:\n        raise SyntaxError(f\"{op_tok.type} requires at least 2 operands\")\n\n    if op_tok.type in self.arith_ops:\n        kind = \"arith\"\n    elif op_tok.type in self.bool_ops:\n        kind = \"bool\"\n    elif op_tok.type in self.comparison_ops:\n        kind = \"compare\"\n    else:\n        raise AssertionError(f\"Unexpected operator: {op_tok}\")  # pragma: no cover\n\n    cond_expr = ASTNode(\n        kind, value=op_tok.type, line=op_tok.line, col=op_tok.col, children=children\n    )\n\n    if self.current().type != \"LBRACE\":\n        raise SyntaxError(\"IF body must be enclosed in braces '{ }'\")\n    then_block = self.parse_block(\"LBRACE\", strict=strict)\n\n    else_block: list[ASTNode] = []\n    if self.current().type == \"ELSE\":\n        self.match(\"ELSE\", strict=strict)\n        if self.current().type != \"LBRACE\":\n            raise SyntaxError(\"ELSE body must be enclosed in braces '{ }'\")\n        else_block = self.parse_block(\"LBRACE\", strict=strict)\n\n    node = ASTNode(\n        \"if\", value=cond_expr, line=if_tok.line, col=if_tok.col, children=then_block\n    )\n    if else_block:\n        node.else_children = else_block\n    return node\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_import","title":"<code>parse_import(strict=True)</code>","text":"<p>Parse an IMPORT statement to load a module from string path.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_import(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse an IMPORT statement to load a module from string path.\"\"\"\n    tok = self.match(\"IMPORT\", \"IDENT\", strict=strict)\n    if tok is None:\n        raise SyntaxError(\"Expected 'IMPORT' keyword\")\n\n    path_tok = self.match(\"STRING\", strict=strict)\n    if path_tok is None:\n        raise SyntaxError(\"Expected string path after IMPORT\")\n\n    return ASTNode(\"import\", path_tok.value, line=tok.line, col=tok.col)\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_input","title":"<code>parse_input(strict=True)</code>","text":"<p>Parse an INPUT statement from stdin or FROM file path.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_input(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse an INPUT statement from stdin or FROM file path.\"\"\"\n    tok = self.match(\"INPUT\", strict=strict)\n    if tok is None:\n        raise SyntaxError(\"Expected 'INPUT' keyword\")\n\n    if self.current().type == \"DELIM_FROM\":\n        self.match(\"DELIM_FROM\", strict=strict)\n        f = self.match(\"IDENT\", \"STRING\", strict=strict)\n        if f is None:\n            raise SyntaxError(\"Expected file path after 'FROM'\")\n\n        varname = (\n            f.value.strip('\"')\n            .strip(\"'\")\n            .split(\"/\")[-1]\n            .split(\"\\\\\")[-1]\n            .split(\".\")[0]\n        )\n\n        return ASTNode(\n            \"input_from_file\",\n            value=varname,\n            children=[ASTNode(\"file\", f.value, line=f.line, col=f.col)],\n            line=tok.line,\n            col=tok.col,\n        )\n\n    var_tok = self.match(\"IDENT\", strict=strict)\n    if var_tok is None:\n        raise SyntaxError(\"Expected variable name after INPUT\")\n\n    node = ASTNode(\n        \"input\", value=var_tok.value, children=[], line=tok.line, col=tok.col\n    )\n\n    if self.current().type == \"COLON\":\n        self.match(\"COLON\", strict=strict)\n        type_tok = self.match(\"IDENT\", strict=strict)\n        if type_tok is None:\n            raise SyntaxError(\"Expected type after colon in input\")\n        node.type = type_tok.value.lower()\n\n    return node\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_loop_block","title":"<code>parse_loop_block(kind, strict=True)</code>","text":"<p>Parse a generic loop block enclosed in braces (used by FOR/WHILE fallback).</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_loop_block(self, kind: str, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a generic loop block enclosed in braces (used by FOR/WHILE fallback).\"\"\"\n    loop_tok = self.match(\n        \"LOOP_FOR\" if kind == \"FOR\" else \"LOOP_WHILE\", strict=strict\n    )\n    assert loop_tok is not None  # for mypy\n\n    if self.current().type != \"LBRACE\":\n        raise SyntaxError(f\"{kind} loop body must be enclosed in braces '{{}}'\")\n\n    body = self.parse_block(\"LBRACE\", strict=strict)\n    if not body:\n        raise SyntaxError(f\"{kind} loop body cannot be empty\")\n\n    return ASTNode(\n        \"loop\", value=kind, line=loop_tok.line, col=loop_tok.col, children=body\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_loop_range","title":"<code>parse_loop_range(strict=True)</code>","text":"<p>Parse a FOR loop with optional AT (start) and BY (step) clauses.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_loop_range(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a FOR loop with optional AT (start) and BY (step) clauses.\"\"\"\n    loop_tok = self.match(\"LOOP_FOR\", strict=strict)\n    assert loop_tok is not None  # for mypy\n\n    var_tok = self.match(\"IDENT\", strict=strict)\n    assert var_tok is not None  # for mypy\n\n    def parse_signed_number() -&gt; Token:\n        if self.current().type == \"SUB\":\n            self.match(\"SUB\", strict=strict)\n            num_tok = self.match(\"NUMBER\", \"FLOAT\", strict=strict)\n            assert num_tok is not None  # for mypy\n            num_tok.value = f\"-{num_tok.value}\"\n            return num_tok\n        num_tok = self.match(\"NUMBER\", \"FLOAT\", strict=strict)\n        assert num_tok is not None  # for mypy\n        return num_tok\n\n    if self.current().type == \"DELIM_AT\":\n        self.match(\"DELIM_AT\", strict=strict)\n        start_tok = parse_signed_number()\n    else:\n        start_tok = Token(\"NUMBER\", \"0\", var_tok.line, var_tok.col)\n\n    self.match(\"DELIM_TO\", strict=strict)\n    end_tok = parse_signed_number()\n\n    step_tok: Token | None = None\n\n    is_delim_by = self.current().type == \"DELIM_BY\"  # split conditional\n    if is_delim_by:\n        print(\"&gt;&gt; HIT 703: Found DELIM_BY\")  # Debug marker for coverage\n        self.match(\"DELIM_BY\", strict=strict)\n        step_tok = parse_signed_number()\n        assert step_tok is not None  # for mypy\n    else:\n        pass  # pragma: no cover\n\n    body = self.parse_block(strict=strict)\n    if not body:\n        raise SyntaxError(\"FOR loop body cannot be empty\")\n\n    range_children = [\n        ASTNode(\"identifier\", var_tok.value, line=var_tok.line, col=var_tok.col),\n        ASTNode(\n            \"number\" if start_tok.type == \"NUMBER\" else \"float\",\n            start_tok.value,\n            line=start_tok.line,\n            col=start_tok.col,\n        ),\n        ASTNode(\n            \"number\" if end_tok.type == \"NUMBER\" else \"float\",\n            end_tok.value,\n            line=end_tok.line,\n            col=end_tok.col,\n        ),\n    ]\n\n    has_step_tok = step_tok is not None  # split conditional\n    if has_step_tok:\n        assert step_tok is not None  # for mypy\n        print(\"&gt;&gt; HIT 726: step_tok assigned\")  # Debug marker for coverage\n        range_children.append(\n            ASTNode(\n                \"number\" if step_tok.type == \"NUMBER\" else \"float\",\n                step_tok.value,\n                line=step_tok.line,\n                col=step_tok.col,\n            )\n        )\n    else:\n        pass  # pragma: no cover\n\n    return ASTNode(\n        \"loop\",\n        value=\"FOR\",\n        line=loop_tok.line,\n        col=loop_tok.col,\n        children=[\n            ASTNode(\"range\", None, range_children),\n            *body,\n        ],\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_loop_while","title":"<code>parse_loop_while(strict=True)</code>","text":"<p>Parse a WHILE loop with condition and body block.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_loop_while(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a WHILE loop with condition and body block.\"\"\"\n    loop_tok = self.match(\"LOOP_WHILE\", strict=strict)\n    if loop_tok is None:\n        raise SyntaxError(\"Expected 'WHILE' loop start\")\n\n    # Parse condition\n    if self.current().type == \"LBRACK\":\n        if self.peek().type == \"RBRACK\":\n            raise SyntaxError(\"WHILE condition cannot be empty\")\n        cond_node = self.parse_expression(strict=strict)\n        assert cond_node is not None  # for mypy\n    else:\n        tok = self.match(\n            \"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", strict=strict\n        )\n        if tok is None:\n            raise SyntaxError(\"Expected condition after WHILE\")\n        kind = \"identifier\" if tok.type == \"IDENT\" else tok.type.lower()\n        cond_node = ASTNode(kind, tok.value, line=tok.line, col=tok.col)\n\n    if self.current().type not in (\"LBRACK\", \"LBRACE\"):\n        raise SyntaxError(\"WHILE must be followed by a block\")\n\n    body = self.parse_block()\n    if not body:\n        raise SyntaxError(\"WHILE loop body cannot be empty\")\n\n    return ASTNode(\n        \"loop\",\n        value=\"WHILE\",\n        line=loop_tok.line,\n        col=loop_tok.col,\n        children=[cond_node] + body,\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_member_access","title":"<code>parse_member_access(strict=True)</code>","text":"Parse chained member access expressions of the form <p>obj.y.z</p> <p>Consumes IDENT, then any number of (DOT IDENT) pairs.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_member_access(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"\n    Parse chained member access expressions of the form:\n        obj.y.z\n    Consumes IDENT, then any number of (DOT IDENT) pairs.\n    \"\"\"\n    ident_tok = self.match(\"IDENT\", strict=strict)\n    if ident_tok is None:\n        raise SyntaxError(\"Expected identifier at start of member access\")\n    assert ident_tok is not None  # for mypy\n\n    node = ASTNode(\n        \"identifier\", ident_tok.value, line=ident_tok.line, col=ident_tok.col\n    )\n\n    while self.current().type == \"DOT\":\n        self.match(\"DOT\", strict=strict)\n        member_tok = self.match(\"IDENT\", strict=strict)\n        if member_tok is None:\n            raise SyntaxError(\"Expected identifier after '.' in member access\")\n        assert member_tok is not None  # for mypy\n\n        node = ASTNode(\n            \"member\",\n            member_tok.value,\n            [node],\n            line=member_tok.line,\n            col=member_tok.col,\n        )\n\n    return node\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_module","title":"<code>parse_module(strict=True)</code>","text":"<p>Parse a module declaration of the form:</p> <pre><code>MODULE Name\nOr, if the lexer emitted it as a generic IDENT \u201cMODULE\u201d:\nIDENT('MODULE') Name\n</code></pre> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_module(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"\n    Parse a module declaration of the form:\n\n        MODULE Name\n        Or, if the lexer emitted it as a generic IDENT \u201cMODULE\u201d:\n        IDENT('MODULE') Name\n    \"\"\"\n    tok = self.match(\"MODULE\", \"IDENT\", strict=strict)\n    if tok is None:\n        raise SyntaxError(\"Expected 'MODULE' keyword\")\n\n    name_tok = self.match(\"IDENT\", strict=strict)\n    if name_tok is None:\n        raise SyntaxError(\"Expected module name after 'MODULE'\")\n\n    return ASTNode(\"module\", value=name_tok.value, line=tok.line, col=tok.col)\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_prefix_operator","title":"<code>parse_prefix_operator(strict=True)</code>","text":"<p>Parse a prefix operator expression like <code>+ x 1</code> or <code>NOT flag</code>.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_prefix_operator(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a prefix operator expression like `+ x 1` or `NOT flag`.\"\"\"\n    op_tok = self.match(\n        \"PLUS\", \"SUB\", \"MULT\", \"DIV\", \"MOD\", \"AND\", \"NOT\", strict=strict\n    )\n    if op_tok is None:\n        raise SyntaxError(\"Expected prefix operator\")\n\n    def parse_operand() -&gt; ASTNode:\n        if self.current().type == \"LBRACK\":\n            expr = self.parse_expression(strict=strict)\n            assert expr is not None  # for mypy\n            return expr\n\n        tok = self.match(\"IDENT\", \"NUMBER\", strict=strict)\n        if tok is None:\n            raise SyntaxError(\"Expected operand after operator\")\n        kind = \"number\" if tok.type == \"NUMBER\" else \"identifier\"\n        return ASTNode(kind, tok.value, line=tok.line, col=tok.col)\n\n    lhs_node = parse_operand()\n    children = [lhs_node]\n\n    if op_tok.type != \"NOT\":\n        rhs_node = parse_operand()\n        children.append(rhs_node)\n\n    kind = (\n        \"arith\" if op_tok.type in (\"PLUS\", \"SUB\", \"MULT\", \"DIV\", \"MOD\") else \"bool\"\n    )\n\n    return ASTNode(\n        kind, value=op_tok.type, line=op_tok.line, col=op_tok.col, children=children\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_print","title":"<code>parse_print(strict=True)</code>","text":"<p>Print statement can be: ! x ! 123 ! \"hello\" ! [ PLUS x 1 ] ! [CALL sum 2 3]</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_print(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"\n    Print statement can be:\n    ! x\n    ! 123\n    ! \"hello\"\n    ! [ PLUS x 1 ]\n    ! [CALL sum 2 3]\n    \"\"\"\n    print_tok = self.match(\"PRINT\", strict=strict)\n    if print_tok is None:\n        raise SyntaxError(\"Expected 'PRINT' keyword\")\n\n    # Bracketed expression: ! [ ... ]\n    if self.current().type == \"LBRACK\":\n        expr = self.parse_expression(strict=strict)\n        if expr is None:\n            raise SyntaxError(\"Expected expression inside brackets\")\n        return ASTNode(\n            \"print\",\n            value=None,\n            children=[expr],\n            line=print_tok.line,\n            col=print_tok.col,\n        )\n\n    # Otherwise, a single literal or identifier\n    tok = self.match(\n        \"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"THIS\", strict=False\n    )\n    if tok is None:\n        return ASTNode(\n            \"print\", value=None, children=[], line=print_tok.line, col=print_tok.col\n        )\n\n    kind = \"identifier\" if tok.type in (\"IDENT\", \"THIS\") else tok.type.lower()\n    child = ASTNode(kind, tok.value, line=tok.line, col=tok.col)\n    return ASTNode(\n        \"print\",\n        value=child.value,\n        children=[child],\n        line=print_tok.line,\n        col=print_tok.col,\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_propagate","title":"<code>parse_propagate(strict=True)</code>","text":"<p>Parse a PROPAGATE (<code>$</code>) statement to forward errors.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_propagate(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a PROPAGATE (`$`) statement to forward errors.\"\"\"\n    if not self.in_block:\n        raise SyntaxError(\"Propagate operator `$` only allowed inside functions.\")\n\n    prop_tok = self.match(\"PROP\", strict=strict)\n    if prop_tok is None:\n        raise SyntaxError(\"Expected '$' propagate operator\")\n\n    if self.current().type == \"LBRACK\":\n        expr = self.parse_expression(strict=strict)\n        if expr is None:\n            raise SyntaxError(\"Expected valid expression after '$'\")\n    else:\n        tok = self.match(\n            \"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"THIS\", strict=strict\n        )\n        if tok is None:\n            raise SyntaxError(\"Expected value after '$'\")\n        kind = \"identifier\" if tok.type in (\"IDENT\", \"THIS\") else tok.type.lower()\n        expr = ASTNode(kind, tok.value, line=tok.line, col=tok.col)\n\n    return ASTNode(\n        \"propagate\",\n        value=None,\n        line=prop_tok.line,\n        col=prop_tok.col,\n        children=[expr],\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_return","title":"<code>parse_return(strict=True)</code>","text":"<p>Parse a RETURN statement with optional expression or value.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_return(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a RETURN statement with optional expression or value.\"\"\"\n    if not self.in_block:\n        raise SyntaxError(\"RETURN is only allowed inside function blocks.\")\n\n    tok = self.match(\"RETURN\", strict=strict)\n\n    # Bracketed expression: RETURN [EXPR]\n    if self.current().type == \"LBRACK\":\n        expr = self.parse_expression(strict=strict)\n        return ASTNode(\n            \"return\",\n            children=[expr],\n            line=tok.line,  # type: ignore\n            col=tok.col,  # type: ignore\n        )\n\n    # Member access: RETURN obj.member\n    if self.current().type == \"IDENT\" and self.peek().type == \"DOT\":\n        member_node = self.parse_member_access()\n        return ASTNode(\n            \"return\",\n            children=[member_node],\n            line=tok.line,  # type: ignore\n            col=tok.col,  # type: ignore\n        )\n\n    # Literal or identifier\n    if self.current().type in (\n        \"IDENT\",\n        \"NUMBER\",\n        \"FLOAT\",\n        \"STRING\",\n        \"LITERAL\",\n        \"THIS\",\n    ):\n        val = self.match(\n            \"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"THIS\", strict=strict\n        )\n        kind = \"identifier\" if val.type in (\"IDENT\", \"THIS\") else val.type.lower()  # type: ignore\n        return ASTNode(\n            \"return\",\n            children=[ASTNode(kind, val.value, line=val.line, col=val.col)],  # type: ignore\n            line=tok.line,  # type: ignore\n            col=tok.col,  # type: ignore\n        )\n\n    # No return value (just RETURN)\n    return ASTNode(\n        \"return\",\n        value=None,\n        line=tok.line,  # type: ignore\n        col=tok.col,  # type: ignore\n    )\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_skip","title":"<code>parse_skip()</code>","text":"<p>Parse a SKIP statement used as a placeholder stub.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_skip(self) -&gt; ASTNode:\n    \"\"\"Parse a SKIP statement used as a placeholder stub.\"\"\"\n    tok = self.match(\"SKIP\", \"IDENT\")\n    assert tok is not None  # for mypy\n\n    return ASTNode(\"skip\", line=tok.line, col=tok.col)\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_statement","title":"<code>parse_statement(strict=True)</code>","text":"<p>Parse a single top-level or block-level LIMIT statement.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_statement(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a single top-level or block-level LIMIT statement.\"\"\"\n    tok = self.current()\n\n    if tok.type == \"COMMA\":\n        self.advance()\n        raise SyntaxError(\"Standalone comma is not a valid statement\")\n\n    if tok.type == \"PROP\":\n        return self.parse_propagate(strict=strict)\n    if tok.type in (\"TRY\", \"IDENT\") and tok.value == \"TRY\":\n        return self.parse_try(strict=strict)\n    if tok.type == \"ASSIGN\":\n        return self.parse_assignment()\n    if tok.type == \"LBRACK\":\n        return self.parse_expression(strict=strict)\n    if tok.type == \"IF\":\n        return self.parse_if()\n    if tok.type in (\"SKIP\", \"IDENT\") and tok.value == \"SKIP\":\n        return self.parse_skip()\n    if tok.type == \"FUNC\":\n        return self.parse_function()\n    if tok.type == \"CALL\":\n        return self.parse_call(strict=strict)\n    if tok.type == \"INPUT\":\n        return self.parse_input()\n    if tok.type == \"PRINT\":\n        return self.parse_print()\n    if tok.type == \"RETURN\":\n        return self.parse_return()\n    if tok.type in (\"BREAK\", \"IDENT\") and tok.value == \"BREAK\":\n        return self.parse_break()\n    if tok.type in (\"CONTINUE\", \"IDENT\") and tok.value == \"CONTINUE\":\n        return self.parse_continue()\n    if tok.type in (\"MODULE\", \"IDENT\") and tok.value == \"MODULE\":\n        return self.parse_module()\n    if tok.type in (\"IMPORT\", \"IDENT\") and tok.value == \"IMPORT\":\n        return self.parse_import()\n    if tok.type in (\"EXPORT\", \"IDENT\") and tok.value == \"EXPORT\":\n        return self.parse_export()\n    if tok.type == \"LOOP_FOR\":\n        if (\n            self.peek().type == \"IDENT\"\n            and self.peek(2).type in (\"DELIM_TO\", \"DELIM_AT\")\n            or self.peek(2).value.lower() in (\"to\", \"at\")\n        ):\n            return self.parse_loop_range()\n        return self.parse_loop_block(\"FOR\")\n    if tok.type == \"LOOP_WHILE\":\n        return self.parse_loop_while(strict=strict)\n    if tok.type == \"CLASS\":\n        return self.parse_class()\n    if tok.type in (\"PLUS\", \"SUB\", \"MULT\", \"DIV\", \"MOD\", \"AND\", \"NOT\"):\n        return self.parse_prefix_operator(strict=strict)\n\n    try:\n        expr = self.parse_expr_or_literal(strict=strict)\n\n        while self.current().type == \"LPAREN\":\n            self.match(\"LPAREN\")\n            args: list[ASTNode] = []\n            if self.current().type != \"RPAREN\":\n                while True:\n                    arg_tok = self.match(\n                        \"IDENT\", \"NUMBER\", \"FLOAT\", \"STRING\", \"LITERAL\", \"THIS\"\n                    )\n                    if arg_tok is None:\n                        raise SyntaxError(\"Expected argument in function call\")\n                    kind = (\n                        \"identifier\"\n                        if arg_tok.type in (\"IDENT\", \"THIS\")\n                        else arg_tok.type.lower()\n                    )\n                    args.append(\n                        ASTNode(\n                            kind, arg_tok.value, line=arg_tok.line, col=arg_tok.col\n                        )\n                    )\n                    if self.current().type == \"COMMA\":\n                        self.match(\"COMMA\")\n                    else:\n                        break\n            self.match(\"RPAREN\")\n            expr = ASTNode(\n                \"call\", value=expr, children=args, line=expr.line, col=expr.col\n            )\n\n        return ASTNode(\"expr_stmt\", children=[expr], line=expr.line, col=expr.col)\n\n    except SyntaxError as e:\n        raise SyntaxError(\n            f\"Unrecognized statement: {tok.value} (type={tok.type})\"\n        ) from e\n</code></pre>"},{"location":"api/limit_parser/#limit.limit_parser.Parser.parse_try","title":"<code>parse_try(strict=True)</code>","text":"<p>Parse a TRY block with CATCH handlers and optional FINALLY.</p> Source code in <code>src/limit/limit_parser.py</code> <pre><code>def parse_try(self, strict: bool = True) -&gt; ASTNode:\n    \"\"\"Parse a TRY block with CATCH handlers and optional FINALLY.\"\"\"\n    try_tok = self.match(\"TRY\", \"IDENT\", strict=strict)\n    if try_tok is None or (try_tok.type == \"IDENT\" and try_tok.value != \"TRY\"):\n        raise SyntaxError(\"Expected 'TRY' keyword\")\n\n    try_block = self.parse_block()\n    catches = []\n\n    while self.current().type == \"CATCH\" or (\n        self.current().type == \"IDENT\" and self.current().value == \"CATCH\"\n    ):\n        catch_tok = self.match(\"CATCH\", \"IDENT\", strict=strict)\n        if catch_tok is None or (\n            catch_tok.type == \"IDENT\" and catch_tok.value != \"CATCH\"\n        ):\n            raise SyntaxError(\"Expected 'CATCH' keyword\")\n\n        if self.current().type == \"LPAREN\":\n            self.match(\"LPAREN\")\n            exc_name_tok = self.match(\"IDENT\", strict=strict)\n            if exc_name_tok is None:\n                raise SyntaxError(\"Expected exception name inside CATCH()\")\n            exc_name = exc_name_tok.value\n            self.match(\"RPAREN\")\n        elif self.current().type == \"IDENT\":\n            exc_name_tok = self.match(\"IDENT\", strict=strict)\n            if exc_name_tok is None:\n                raise SyntaxError(\"Expected exception name in CATCH\")\n            exc_name = exc_name_tok.value\n        else:\n            exc_name = None\n\n        catch_block = self.parse_block()\n        catches.append(\n            ASTNode(\n                \"catch\",\n                exc_name,\n                catch_block,\n                line=catch_tok.line,\n                col=catch_tok.col,\n            )\n        )\n\n    finally_node = None\n    if self.current().type == \"FINALLY\" or (\n        self.current().type == \"IDENT\" and self.current().value == \"FINALLY\"\n    ):\n        finally_tok = self.match(\"FINALLY\", \"IDENT\", strict=strict)\n        finally_block = self.parse_block()\n        finally_node = ASTNode(\n            \"finally\",\n            None,\n            finally_block,\n            line=finally_tok.line,  # type: ignore\n            col=finally_tok.col,  # type: ignore\n        )\n\n    children = try_block\n    children.extend(catches)\n    if finally_node:\n        children.append(finally_node)\n\n    return ASTNode(\"try\", None, children, line=try_tok.line, col=try_tok.col)\n</code></pre>"},{"location":"api/limit_py_emitter/","title":"Python Emitter","text":"<p>Translates LIMIT AST nodes into executable Python code.</p> <p>This module defines the <code>PythonEmitter</code> class, responsible for converting LIMIT's abstract syntax trees (ASTs) into valid and idiomatic Python source code. It is used by the <code>Transpiler</code> during the backend phase of LIMIT's compilation process.</p> Supported Features <ul> <li>Expressions: arithmetic, boolean, comparison, function calls, object creation, member access</li> <li>Statements: assignment, print, return, propagate, break, continue, import</li> <li>Control flow: IF/ELSE blocks, WHILE loops, FOR loops with optional range/step</li> <li>Classes: inheritance with automatic <code>super().__init__()</code> injection</li> <li>Functions: with parameter parsing and optional return type annotations</li> <li>Modules: <code>EXPORT</code> support via Python <code>__all__</code> list</li> <li>Expression emission and full AST walking</li> </ul> Behavior <ul> <li>Emits structured Python code with proper indentation.</li> <li>Maintains a code buffer (<code>lines</code>) which can be retrieved using <code>get_output()</code>.</li> </ul> <p>Raises:</p> Type Description <code>- `TypeError`</code> <p>If invalid AST structures are encountered during emission.</p> <code>- `NotImplementedError`</code> <p>If an unrecognized AST kind has no corresponding emitter.</p> <p>This emitter is the backend target for generating runnable Python from LIMIT programs.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter","title":"<code>PythonEmitter()</code>","text":"<p>Emits Python code from LIMIT AST nodes.</p> <p>This class converts abstract syntax trees (AST) from the LIMIT language into valid, runnable Python code. It implements emitters for all major syntax constructs including expressions, statements, control flow, functions, classes, and module-level features.</p> <p>Attributes:</p> Name Type Description <code>lines</code> <code>list[str]</code> <p>Accumulated lines of emitted Python code.</p> <code>indent</code> <code>int</code> <p>Current indentation level for emitted code blocks.</p> <code>exports</code> <code>list[str]</code> <p>List of exported symbols to include in all.</p> <p>Methods:</p> Name Description <code>get_output</code> <p>Returns the full emitted Python code as a string.</p> <code>emit_expr</code> <p>Emits a Python expression from an AST node.</p> <code>_visit</code> <p>Dispatches to the appropriate emit_* method for a node.</p> <p>Initializes the emitter with an empty code buffer, zero indentation, and no exports.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initializes the emitter with an empty code buffer, zero indentation, and no exports.\n    \"\"\"\n    self.lines: list[str] = []\n    self.indent = 0\n    self.exports: list[str] = []\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_assign","title":"<code>emit_assign(node)</code>","text":"<p>Emits an assignment statement.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_assign--parameters","title":"Parameters","text":"<p>node : ASTNode     An assignment node with lhs and rhs children.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_assign(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits an assignment statement.\n\n    Parameters\n    ----------\n    node : ASTNode\n        An assignment node with lhs and rhs children.\n    \"\"\"\n    rhs = self.emit_expr(node.children[1])\n    lhs = self.emit_expr(node.children[0])\n    self.lines.append(f\"{self.indent_str()}{lhs} = {rhs}\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_break","title":"<code>emit_break(node)</code>","text":"<p>Emits a <code>break</code> statement to exit a loop.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_break--parameters","title":"Parameters","text":"<p>node : ASTNode     A break node with no children.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_break(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a `break` statement to exit a loop.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A break node with no children.\n    \"\"\"\n    self.lines.append(f\"{self.indent_str()}break\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_call","title":"<code>emit_call(node)</code>","text":"<p>Emits a function or method call as a standalone statement.</p> <p>Converts the call expression into a line of Python code.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_call--parameters","title":"Parameters","text":"<p>node : ASTNode     A call node with the callee in <code>value</code> and arguments in <code>children</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_call(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a function or method call as a standalone statement.\n\n    Converts the call expression into a line of Python code.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A call node with the callee in `value` and arguments in `children`.\n    \"\"\"\n    self.lines.append(f\"{self.indent_str()}{self.emit_expr_call(node)}\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_class","title":"<code>emit_class(node)</code>","text":"<p>Emits a class definition with optional inheritance and methods.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_class--parameters","title":"Parameters","text":"<p>node : ASTNode     The class node with name in <code>value</code> and children for body and <code>extends</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_class(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a class definition with optional inheritance and methods.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The class node with name in `value` and children for body and `extends`.\n    \"\"\"\n    base = \"object\"\n    new_children = []\n\n    # Determine base class and filter out 'extends'\n    for child in node.children:\n        if child.kind == \"extends\":\n            if not isinstance(child.value, str):\n                raise TypeError(\"Expected string in class extends base\")\n            base = child.value\n        else:\n            new_children.append(child)\n\n    self.lines.append(f\"{self.indent_str()}class {node.value}({base}):\")\n    self.indent += 1\n\n    if not new_children:\n        self.lines.append(f\"{self.indent_str()}pass\")\n\n    for child in new_children:\n        if child.kind == \"func\":  # pragma: no branch\n            child._in_class = True\n            if child.value == \"init\":\n                child.value = \"__init__\"\n\n                if base != \"object\":\n                    super_call = ASTNode(\n                        kind=\"call\",\n                        value=ASTNode(\n                            kind=\"member\",\n                            value=\"__init__\",\n                            children=[\n                                ASTNode(\n                                    kind=\"call\",\n                                    value=ASTNode(kind=\"identifier\", value=\"super\"),\n                                    children=[],\n                                )\n                            ],\n                        ),\n                        children=[],\n                    )\n                    child.children.insert(\n                        0, ASTNode(kind=\"expr_stmt\", children=[super_call])\n                    )\n\n        self._visit(child)\n\n    self.indent -= 1\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_continue","title":"<code>emit_continue(node)</code>","text":"<p>Emits a <code>continue</code> statement to skip to the next iteration of a loop.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_continue--parameters","title":"Parameters","text":"<p>node : ASTNode     A continue node with no children.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_continue(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a `continue` statement to skip to the next iteration of a loop.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A continue node with no children.\n    \"\"\"\n    self.lines.append(f\"{self.indent_str()}continue\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_export","title":"<code>emit_export(node)</code>","text":"<p>Emits an export declaration by adding the symbol to <code>__all__</code>.</p> <p>Also emits the associated child node, if present.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_export--parameters","title":"Parameters","text":"<p>node : ASTNode     An export node with the exported symbol in <code>value</code> and optional child.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_export(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits an export declaration by adding the symbol to `__all__`.\n\n    Also emits the associated child node, if present.\n\n    Parameters\n    ----------\n    node : ASTNode\n        An export node with the exported symbol in `value` and optional child.\n    \"\"\"\n    self.exports.append(str(node.value))\n    if node.children:\n        self._visit(node.children[0])\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr","title":"<code>emit_expr(node)</code>","text":"<p>Dispatches expression emission based on node kind.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr--parameters","title":"Parameters","text":"<p>node : ASTNode     The expression node to emit.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr--returns","title":"Returns","text":"<p>str     The resulting Python code for the expression.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr--raises","title":"Raises","text":"<p>NotImplementedError     If no emitter exists for the node kind.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Dispatches expression emission based on node kind.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The expression node to emit.\n\n    Returns\n    -------\n    str\n        The resulting Python code for the expression.\n\n    Raises\n    ------\n    NotImplementedError\n        If no emitter exists for the node kind.\n    \"\"\"\n    preferred = (\n        \"arith\",\n        \"bool\",\n        \"compare\",\n        \"member\",\n        \"call\",\n        \"new\",\n        \"identifier\",\n        \"number\",\n        \"float\",\n        \"string\",\n        \"file\",\n        \"empty\",\n    )\n    kind = node.kind\n\n    if kind in preferred:\n        method = getattr(self, f\"emit_expr_{kind}\", None)\n        if callable(method):\n            # pylint: disable=not-callable\n            return str(method(node))\n\n    fallback = getattr(self, f\"emit_{kind}\", None)\n    if callable(fallback):\n        # pylint: disable=not-callable\n        return str(fallback(node))\n\n    raise NotImplementedError(f\"No expression emitter for kind '{kind}'\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_bool","title":"<code>emit_expr_bool(node)</code>","text":"<p>Emits a boolean expression with <code>AND</code>, <code>OR</code>, <code>NOT</code>, or <code>TRUTHY</code>.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_bool--parameters","title":"Parameters","text":"<p>node : ASTNode     The boolean AST node.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_bool--returns","title":"Returns","text":"<p>str     A valid Python boolean expression.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr_bool(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Emits a boolean expression with `AND`, `OR`, `NOT`, or `TRUTHY`.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The boolean AST node.\n\n    Returns\n    -------\n    str\n        A valid Python boolean expression.\n    \"\"\"\n    if node.value == \"NOT\":\n        e = self.emit_expr(node.children[0])\n        return f\"(not {e})\"\n    if node.value == \"TRUTHY\":\n        e = self.emit_expr(node.children[0])\n        return f\"bool({e})\"\n    left = self.emit_expr(node.children[0])\n    right = self.emit_expr(node.children[1])\n    op = \"and\" if node.value == \"AND\" else \"or\"\n    return f\"({left} {op} {right})\"\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_call","title":"<code>emit_expr_call(node)</code>","text":"<p>Emits a function or method call expression.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_call--parameters","title":"Parameters","text":"<p>node : ASTNode     A call node with the callee as value and arguments as children.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_call--returns","title":"Returns","text":"<p>str     A valid Python function call.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr_call(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Emits a function or method call expression.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A call node with the callee as value and arguments as children.\n\n    Returns\n    -------\n    str\n        A valid Python function call.\n    \"\"\"\n    if not isinstance(node.value, ASTNode):\n        raise TypeError(\"Expected ASTNode for call callee\")\n    callee = self.emit_expr(node.value)\n    args = \", \".join(self.emit_expr(c) for c in node.children)\n    return f\"{callee}({args})\"\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_compare","title":"<code>emit_expr_compare(node)</code>","text":"<p>Emits a comparison expression (e.g., <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.).</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_compare--parameters","title":"Parameters","text":"<p>node : ASTNode     A compare node with two expression children and a comparison operator in <code>value</code>.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_compare--returns","title":"Returns","text":"<p>str     The emitted Python comparison expression.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr_compare(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Emits a comparison expression (e.g., `&lt;`, `&gt;`, `==`, etc.).\n\n    Parameters\n    ----------\n    node : ASTNode\n        A compare node with two expression children and a comparison operator in `value`.\n\n    Returns\n    -------\n    str\n        The emitted Python comparison expression.\n    \"\"\"\n    left = self.emit_expr(node.children[0])\n    right = self.emit_expr(node.children[1])\n    op = {\n        \"LT\": \"&lt;\",\n        \"GT\": \"&gt;\",\n        \"EQ\": \"==\",\n        \"NE\": \"!=\",\n        \"LE\": \"&lt;=\",\n        \"GE\": \"&gt;=\",\n    }.get(str(node.value), str(node.value))\n    return f\"({left} {op} {right})\"\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_member","title":"<code>emit_expr_member(node)</code>","text":"<p>Emits attribute access like <code>obj.attr</code>.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_member--parameters","title":"Parameters","text":"<p>node : ASTNode     The member access node.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_member--returns","title":"Returns","text":"<p>str     The emitted Python member access string.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr_member(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Emits attribute access like `obj.attr`.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The member access node.\n\n    Returns\n    -------\n    str\n        The emitted Python member access string.\n    \"\"\"\n    base = self.emit_expr(node.children[0])\n    return f\"{base}.{str(node.value)}\"\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_new","title":"<code>emit_expr_new(node)</code>","text":"<p>Emits object instantiation using a class name and arguments.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_new--parameters","title":"Parameters","text":"<p>node : ASTNode     The new object creation node.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_new--returns","title":"Returns","text":"<p>str     Python code for calling the class constructor.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr_new(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Emits object instantiation using a class name and arguments.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The new object creation node.\n\n    Returns\n    -------\n    str\n        Python code for calling the class constructor.\n    \"\"\"\n    args = \", \".join(self.emit_expr(c) for c in node.children)\n    return f\"{str(node.value)}({args})\" if args else f\"{str(node.value)}()\"\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_stmt","title":"<code>emit_expr_stmt(node)</code>","text":"<p>Emits a standalone expression statement.</p> <p>Typically used for expressions with side effects that are not assigned.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_expr_stmt--parameters","title":"Parameters","text":"<p>node : ASTNode     A node containing one expression child to be evaluated.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_expr_stmt(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a standalone expression statement.\n\n    Typically used for expressions with side effects that are not assigned.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A node containing one expression child to be evaluated.\n    \"\"\"\n    expr_code = self.emit_expr(node.children[0])\n    self.lines.append(f\"{self.indent_str()}{expr_code}\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_func","title":"<code>emit_func(node)</code>","text":"<p>Emits a function or method definition.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_func--parameters","title":"Parameters","text":"<p>node : ASTNode     The function node, with name in <code>value</code>, params in <code>type</code>, and body in <code>children</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_func(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a function or method definition.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The function node, with name in `value`, params in `type`, and body in `children`.\n    \"\"\"\n    if isinstance(node.type, str):\n        raw_params = node.type.split(\",\")\n    elif isinstance(node.type, list):\n        raw_params = node.type\n    else:\n        raw_params = []\n\n    is_method = hasattr(node, \"_in_class\") and node._in_class is True\n    cleaned = [p.strip() for p in raw_params if p.strip()]\n    if is_method and \"self\" not in cleaned:\n        cleaned.insert(0, \"self\")\n\n    sig = f\"def {node.value}({', '.join(cleaned)}):\"\n    if node.return_type:\n        sig = sig[:-1] + f\" -&gt; {node.return_type}:\"\n\n    self.lines.append(f\"{self.indent_str()}{sig}\")\n    self.indent += 1\n    if not node.children:\n        self.lines.append(f\"{self.indent_str()}pass\")\n    for stmt in node.children:\n        self._visit(stmt)\n    self.indent -= 1\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_if","title":"<code>emit_if(node)</code>","text":"<p>Emits an <code>if</code> statement with optional <code>else</code> block.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_if--parameters","title":"Parameters","text":"<p>node : ASTNode     The if-node with condition in <code>value</code>, body in <code>children</code>, and optional <code>else_children</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_if(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits an `if` statement with optional `else` block.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The if-node with condition in `value`, body in `children`, and optional `else_children`.\n    \"\"\"\n    if not isinstance(node.value, ASTNode):\n        raise TypeError(\"Expected ASTNode in value of IF condition\")\n    cond_expr = self.emit_expr(\n        node.value\n    )  # Fix: emit condition from node.value, not children\n    self.lines.append(f\"{self.indent_str()}if {cond_expr}:\")\n    self.indent += 1\n    for stmt in node.children:\n        self._visit(stmt)\n    self.indent -= 1\n\n    if getattr(node, \"else_children\", None):\n        self.lines.append(f\"{self.indent_str()}else:\")\n        self.indent += 1\n        for stmt in node.else_children:\n            self._visit(stmt)\n        self.indent -= 1\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_import","title":"<code>emit_import(node)</code>","text":"<p>Emits an <code>import</code> statement.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_import--parameters","title":"Parameters","text":"<p>node : ASTNode     An import node with the module name in <code>value</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_import(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits an `import` statement.\n\n    Parameters\n    ----------\n    node : ASTNode\n        An import node with the module name in `value`.\n    \"\"\"\n    self.lines.append(f\"{self.indent_str()}import {node.value}\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_input","title":"<code>emit_input(node)</code>","text":"<p>Emits an input statement that assigns user input to a variable.</p> <p>Converts input to <code>int</code> or <code>float</code> if a type is specified, otherwise uses raw <code>input()</code>.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_input--parameters","title":"Parameters","text":"<p>node : ASTNode     An input node with the target variable in <code>value</code> and optional type in <code>type</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_input(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits an input statement that assigns user input to a variable.\n\n    Converts input to `int` or `float` if a type is specified, otherwise uses raw `input()`.\n\n    Parameters\n    ----------\n    node : ASTNode\n        An input node with the target variable in `value` and optional type in `type`.\n    \"\"\"\n    line = self.indent_str()\n    var = node.value\n    if getattr(node, \"type\", None) == \"int\":\n        self.lines.append(f\"{line}{var} = int(input())\")\n    elif node.type == \"float\":\n        self.lines.append(f\"{line}{var} = float(input())\")\n    else:\n        self.lines.append(f\"{line}{var} = input()\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_input_from_file","title":"<code>emit_input_from_file(node)</code>","text":"<p>Emits code to read a file's contents into a variable.</p> <p>If the file is not found, assigns <code>None</code> to the variable.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_input_from_file--parameters","title":"Parameters","text":"<p>node : ASTNode     A node with the target variable in <code>value</code> and a single child representing the filename.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_input_from_file(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits code to read a file's contents into a variable.\n\n    If the file is not found, assigns `None` to the variable.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A node with the target variable in `value` and a single child representing the filename.\n    \"\"\"\n    child = node.children[0]\n    if not isinstance(child, ASTNode):\n        raise TypeError(\"Expected ASTNode in children[0]\")\n\n    filename = self.emit_expr(child)\n    var = node.value\n    self.lines.append(\n        f\"{self.indent_str()}try:\\n\"\n        f\"{self.indent_str()}    {var} = open({filename}).read()\\n\"\n        f\"{self.indent_str()}except FileNotFoundError:\\n\"\n        f\"{self.indent_str()}    {var} = None\"\n    )\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_literal","title":"<code>emit_literal(node)</code>","text":"<p>Emits a binary arithmetic expression (e.g., +, -, *, /, %) as Python syntax.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_literal--parameters","title":"Parameters","text":"<p>node : ASTNode     An AST node with operator as value and two children.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_literal--returns","title":"Returns","text":"<p>str     The emitted Python expression.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_literal(self, node: ASTNode) -&gt; str:\n    \"\"\"\n    Emits a binary arithmetic expression (e.g., +, -, *, /, %) as Python syntax.\n\n    Parameters\n    ----------\n    node : ASTNode\n        An AST node with operator as value and two children.\n\n    Returns\n    -------\n    str\n        The emitted Python expression.\n    \"\"\"\n    val = str(node.value)\n    if val == \"TRUE\":\n        return \"True\"\n    if val == \"FALSE\":\n        return \"False\"\n    if val == \"NULL\":\n        return \"None\"\n    raise ValueError(f\"Unknown literal: {node.value}\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_loop","title":"<code>emit_loop(node)</code>","text":"<p>Emits either a <code>for</code> or <code>while</code> loop depending on node type.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_loop--parameters","title":"Parameters","text":"<p>node : ASTNode     A loop node containing loop header and body.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_loop(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits either a `for` or `while` loop depending on node type.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A loop node containing loop header and body.\n    \"\"\"\n    if node.value == \"FOR\" and node.children and node.children[0].kind == \"range\":\n        range_node = node.children[0]\n        var = str(range_node.children[0].value)\n\n        # Defaults\n        start = \"0\"\n        end = None\n        step = None\n\n        if len(range_node.children) == 2:\n            # FOR i TO N  =&gt;  range(0, N)\n            end = str(range_node.children[1].value)\n        elif len(range_node.children) == 3:\n            # FOR i AT A TO B  =&gt;  range(A, B)\n            start = str(range_node.children[1].value)\n            end = str(range_node.children[2].value)\n        elif len(range_node.children) == 4:  # pragma: no branch\n            # FOR i AT A TO B BY C  =&gt;  range(A, B, C)\n            start = str(range_node.children[1].value)\n            end = str(range_node.children[2].value)\n            step = str(range_node.children[3].value)\n\n        range_expr = f\"range({start}, {end}\" + (f\", {step})\" if step else \")\")\n        self.lines.append(f\"{self.indent_str()}for {var} in {range_expr}:\")\n        self.indent += 1\n        for stmt in node.children[1:]:\n            self._visit(stmt)\n        self.indent -= 1\n\n    else:\n        # WHILE loop\n        cond = self.emit_expr(node.children[0])\n        self.lines.append(f\"{self.indent_str()}while {cond}:\")\n        self.indent += 1\n        for stmt in node.children[1:]:\n            self._visit(stmt)\n        self.indent -= 1\n\n    if getattr(node, \"else_children\", None):\n        raise NotImplementedError(\"ELSE blocks are only valid after IF, not loops.\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_print","title":"<code>emit_print(node)</code>","text":"<p>Emits a <code>print</code> statement.</p> <p>If no children are present, emits <code>print()</code> with no arguments. Otherwise, emits <code>print(expr)</code> using the first child as the expression.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_print--parameters","title":"Parameters","text":"<p>node : ASTNode     A print node with zero or one expression child.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_print(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a `print` statement.\n\n    If no children are present, emits `print()` with no arguments.\n    Otherwise, emits `print(expr)` using the first child as the expression.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A print node with zero or one expression child.\n    \"\"\"\n    if not node.children:\n        self.lines.append(f\"{self.indent_str()}print()\")\n    else:\n        e = self.emit_expr(node.children[0])\n        self.lines.append(f\"{self.indent_str()}print({e})\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_propagate","title":"<code>emit_propagate(node)</code>","text":"<p>Emits a <code>PROPAGATE</code>-style conditional return.</p> <p>Evaluates the expression and stores it in a temporary variable. Emits <code>if __tmp: return __tmp</code> to return only if the result is truthy.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_propagate--parameters","title":"Parameters","text":"<p>node : ASTNode     A propagate node containing a single expression child.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_propagate(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a `PROPAGATE`-style conditional return.\n\n    Evaluates the expression and stores it in a temporary variable.\n    Emits `if __tmp: return __tmp` to return only if the result is truthy.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A propagate node containing a single expression child.\n    \"\"\"\n    tmp = \"__tmp\"\n    e = node.children[0]\n    if not isinstance(e, ASTNode):\n        raise TypeError(\"Expected ASTNode in propagate\")\n\n    expr: str = self.emit_expr(e)\n    self.lines.append(f\"{self.indent_str()}{tmp} = {expr}\")\n    self.lines.append(f\"{self.indent_str()}if {tmp}: return {tmp}\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_return","title":"<code>emit_return(node)</code>","text":"<p>Emits a <code>return</code> statement.</p> <p>If the node has children, emits <code>return expr</code> using the first child as the return value. If no children are present, emits a bare <code>return</code>.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_return--parameters","title":"Parameters","text":"<p>node : ASTNode     A return node with optional expression child.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_return(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a `return` statement.\n\n    If the node has children, emits `return expr` using the first child as the return value.\n    If no children are present, emits a bare `return`.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A return node with optional expression child.\n    \"\"\"\n    if node.children:\n        v = self.emit_expr(node.children[0])\n        self.lines.append(f\"{self.indent_str()}return {v}\")\n    else:\n        self.lines.append(f\"{self.indent_str()}return\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_skip","title":"<code>emit_skip(node)</code>","text":"<p>Emits a <code>pass</code> statement, typically used for stubbed functions or classes.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_skip--parameters","title":"Parameters","text":"<p>node : ASTNode     A skip node with no operational content.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_skip(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a `pass` statement, typically used for stubbed functions or classes.\n\n    Parameters\n    ----------\n    node : ASTNode\n        A skip node with no operational content.\n    \"\"\"\n    self.lines.append(f\"{self.indent_str()}pass\")\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_try","title":"<code>emit_try(node)</code>","text":"<p>Emits a try-catch-finally block.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.emit_try--parameters","title":"Parameters","text":"<p>node : ASTNode     The try block with children containing <code>try</code>, <code>catch</code>, and optionally <code>finally</code>.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def emit_try(self, node: ASTNode) -&gt; None:\n    \"\"\"\n    Emits a try-catch-finally block.\n\n    Parameters\n    ----------\n    node : ASTNode\n        The try block with children containing `try`, `catch`, and optionally `finally`.\n    \"\"\"\n    self.lines.append(f\"{self.indent_str()}try:\")\n    self.indent += 1\n    for c in node.children:\n        if c.kind in (\"catch\", \"finally\"):\n            break\n        self._visit(c)\n    self.indent -= 1\n\n    for c in node.children:\n        if c.kind == \"catch\":\n            header = (\n                f\"except Exception as {c.value}:\"\n                if c.value\n                else \"except Exception:\"\n            )\n            self.lines.append(f\"{self.indent_str()}{header}\")\n            self.indent += 1\n            for stmt in c.children:\n                self._visit(stmt)\n            self.indent -= 1\n\n    for c in node.children:\n        if c.kind == \"finally\":\n            self.lines.append(f\"{self.indent_str()}finally:\")\n            self.indent += 1\n            for stmt in c.children:\n                self._visit(stmt)\n            self.indent -= 1\n</code></pre>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.get_output","title":"<code>get_output()</code>","text":"<p>Returns the full emitted Python code as a single string.</p>"},{"location":"api/limit_py_emitter/#limit.emitters.py_emitter.PythonEmitter.get_output--returns","title":"Returns","text":"<p>str     The joined lines of Python code, with <code>__all__</code> inserted if exports are present.</p> Source code in <code>src/limit/emitters/py_emitter.py</code> <pre><code>def get_output(self) -&gt; str:\n    \"\"\"\n    Returns the full emitted Python code as a single string.\n\n    Returns\n    -------\n    str\n        The joined lines of Python code, with `__all__` inserted if exports are present.\n    \"\"\"\n    if self.exports:\n        self.lines.insert(0, f\"__all__ = {self.exports!r}\")\n    return \"\\n\".join(self.lines)\n</code></pre>"},{"location":"api/limit_repl/","title":"REPL","text":"<p>Interactive REPL (Read-Eval-Print Loop) for the LIMIT programming language.</p> <p>This module provides an interactive command-line loop for writing, parsing, and executing LIMIT code in real time. It enables users to experiment with the LIMIT language directly.</p> Features <ul> <li>Parses and evaluates both expressions and full LIMIT statements.</li> <li>Transpiles LIMIT source code to a target language (default: Python).</li> <li>Executes code using a shared session environment.</li> <li>Handles multi-line bracket-balanced input.</li> <li>Supports alias remapping via inline <code>SUGAR</code> commands.</li> <li>Enables importing external <code>.limit</code> files within the REPL session.</li> <li>Offers a toggleable verbose mode for inspecting emitted Python expressions.</li> </ul> <p>Functions:</p> Name Description <code>- `start_repl</code> <p>str = \"py\", verbose: bool = False)`: Launches the REPL with optional target and verbosity.</p> <code>- `handle_sugar_command</code> <p>str) -&gt; bool`: Parses and applies alias remapping commands.</p> <code>- `is_expression_node</code> <p>ASTNode) -&gt; bool`: Determines whether a node is an expression.</p> <code>- `print_traceback</code> <p>Prints any exception raised during transpilation or execution.</p> <code>- `main</code> <p>Entry point for standalone REPL mode.</p>"},{"location":"api/limit_repl/#limit.limit_repl.handle_sugar_command","title":"<code>handle_sugar_command(src)</code>","text":"<p>Handles dynamic <code>SUGAR</code> commands in the LIMIT REPL for alias configuration.</p> <p>If the input string starts with <code>SUGAR</code>, this function parses the remainder as a mapping of aliases to token symbols. It supports grouped aliases using Python literals (e.g., <code>{\"and\": \"AND\", (\"plus\", \"add\"): \"PLUS\"}</code>) and updates the internal alias mapper accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The raw input string entered into the REPL.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the command was recognized and handled; False otherwise.</p> Source code in <code>src/limit/limit_repl.py</code> <pre><code>def handle_sugar_command(src: str) -&gt; bool:\n    \"\"\"\n    Handles dynamic `SUGAR` commands in the LIMIT REPL for alias configuration.\n\n    If the input string starts with `SUGAR`, this function parses the remainder\n    as a mapping of aliases to token symbols. It supports grouped aliases using\n    Python literals (e.g., `{\"and\": \"AND\", (\"plus\", \"add\"): \"PLUS\"}`) and\n    updates the internal alias mapper accordingly.\n\n    Args:\n        src: The raw input string entered into the REPL.\n\n    Returns:\n        True if the command was recognized and handled; False otherwise.\n    \"\"\"\n    src = src.strip()\n    if not src.upper().startswith(\"SUGAR\"):\n        return False\n    command = src[5:].strip()\n    if command == \"\":\n        print(uimap.report(verbose=True))\n        return True\n    try:\n        command = re.sub(r\"\\[\\s*(.*?)\\s*\\]\", lambda m: \"(\" + m.group(1) + \",)\", command)\n        raw_map = eval(\n            command, {}, {}\n        )  # Unsafe in prod, safe here due to controlled context\n        final_mapping: dict[str, str] = {}\n        for key, sym in raw_map.items():\n            if isinstance(key, (list, tuple, set)):\n                for alias in key:\n                    final_mapping[str(alias)] = sym\n            else:\n                final_mapping[str(key)] = sym\n        uimap.configure(final_mapping)\n        print(\"[ok] &gt;&gt;&gt; Sugar aliases updated.\")\n        print(\n            \"\\n\".join(\n                f\"{alias:&gt;12} \u2192 {sym}\" for alias, sym in sorted(final_mapping.items())\n            )\n        )\n    except Exception as e:\n        print(\"[error] &gt;&gt;&gt; Failed to configure sugar aliases:\")\n        print(e)\n    return True\n</code></pre>"},{"location":"api/limit_repl/#limit.limit_repl.is_expression_node","title":"<code>is_expression_node(node)</code>","text":"<p>Determines whether a given AST node represents an expression.</p> <p>This includes basic expressions like arithmetic, boolean, identifiers, literals, calls, and member accesses, as well as top-level <code>expr_stmt</code> nodes whose children are valid expression kinds.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ASTNode</code> <p>The AST node to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the node is an expression node, False otherwise.</p> Source code in <code>src/limit/limit_repl.py</code> <pre><code>def is_expression_node(node: ASTNode) -&gt; bool:\n    \"\"\"\n    Determines whether a given AST node represents an expression.\n\n    This includes basic expressions like arithmetic, boolean, identifiers,\n    literals, calls, and member accesses, as well as top-level `expr_stmt` nodes\n    whose children are valid expression kinds.\n\n    Args:\n        node (ASTNode): The AST node to check.\n\n    Returns:\n        bool: True if the node is an expression node, False otherwise.\n    \"\"\"\n    is_base_expr = node.kind in {\n        \"arith\",\n        \"bool\",\n        \"identifier\",\n        \"call\",\n        \"member\",\n        \"float\",\n        \"number\",\n        \"string\",\n        \"new\",\n    }\n\n    is_expr_stmt = (\n        node.kind == \"expr_stmt\"\n        and bool(node.children)\n        and node.children[0].kind\n        in {\"call\", \"member\", \"identifier\", \"arith\", \"bool\", \"compare\", \"new\"}\n    )\n\n    return (is_base_expr or is_expr_stmt) and node.kind != \"print\"\n</code></pre>"},{"location":"api/limit_repl/#limit.limit_repl.print_traceback","title":"<code>print_traceback()</code>","text":"<p>Captures and prints the current exception traceback.</p> <p>This function redirects the traceback output to a string buffer, then prints it with a standardized error prefix.</p> Source code in <code>src/limit/limit_repl.py</code> <pre><code>def print_traceback() -&gt; None:\n    \"\"\"\n    Captures and prints the current exception traceback.\n\n    This function redirects the traceback output to a string buffer,\n    then prints it with a standardized error prefix.\n    \"\"\"\n    buf = io.StringIO()\n    traceback.print_exc(file=buf)\n    print(\"[error] &gt;&gt;&gt;\")\n    print(buf.getvalue())\n</code></pre>"},{"location":"api/limit_repl/#limit.limit_repl.start_repl","title":"<code>start_repl(target='py', verbose=False)</code>","text":"<p>Launches the interactive REPL (Read-Eval-Print Loop) for the LIMIT language.</p> <p>The REPL allows users to type LIMIT statements or expressions line by line. It supports:   - Multi-line block parsing with brace matching   - Dynamic expression evaluation and statement execution   - Importing external <code>.limit</code> files   - Real-time sugar alias remapping via <code>SUGAR</code> commands   - Verbose mode for debugging emitted Python expressions   - Module context switching with <code>MODULE</code> declarations</p> <p>Transpilation occurs to the selected <code>target</code> language (default: Python), and execution is done in a shared <code>env_globals</code> namespace for persistence.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The transpilation target (e.g., \"py\" or \"c\").</p> <code>'py'</code> <code>verbose</code> <code>bool</code> <p>If True, prints emitted Python expressions before execution.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/limit/limit_repl.py</code> <pre><code>def start_repl(target: str = \"py\", verbose: bool = False) -&gt; None:\n    \"\"\"\n    Launches the interactive REPL (Read-Eval-Print Loop) for the LIMIT language.\n\n    The REPL allows users to type LIMIT statements or expressions line by line.\n    It supports:\n      - Multi-line block parsing with brace matching\n      - Dynamic expression evaluation and statement execution\n      - Importing external `.limit` files\n      - Real-time sugar alias remapping via `SUGAR` commands\n      - Verbose mode for debugging emitted Python expressions\n      - Module context switching with `MODULE` declarations\n\n    Transpilation occurs to the selected `target` language (default: Python),\n    and execution is done in a shared `env_globals` namespace for persistence.\n\n    Args:\n        target: The transpilation target (e.g., \"py\" or \"c\").\n        verbose: If True, prints emitted Python expressions before execution.\n\n    Returns:\n        None\n    \"\"\"\n    print(f\"Limit REPL [target={target}]. Type 'exit' or 'quit' to leave.\")\n    env_globals: dict[str, Any] = {}\n    current_module: str | None = None\n    imported_files: set[str] = set()\n\n    while True:\n        try:\n            src_lines: list[str] = []\n            brace_count = 0\n            while True:\n                prompt = \"&gt;&gt;&gt; \" if not src_lines else \"... \"\n                line = input(prompt)\n                if line.strip() in (\"exit\", \"quit\") and not src_lines:\n                    print(\"Exiting Limit REPL.\")\n                    return\n                src_lines.append(line)\n                brace_count += line.count(\"{\") - line.count(\"}\")\n                if brace_count &lt;= 0 and (\n                    line.strip().endswith(\"}\")\n                    or not any(\"{\" in line_ for line_ in src_lines)\n                ):  # pragma: no branch\n                    break\n            src = \"\\n\".join(src_lines).strip()\n            if not src:\n                continue\n            if src.strip().startswith(\"#\"):\n                continue\n            if src.lower() == \"verbose-mode\":\n                verbose = not verbose\n                print(f\"[mode] &gt;&gt;&gt; Verbose mode {'ON' if verbose else 'OFF'}\")\n                continue\n            if handle_sugar_command(src):\n                continue\n            if src.upper().startswith(\"MODULE \"):\n                current_module = src.split(\"MODULE\", 1)[1].strip()\n                print(f\"[module] &gt;&gt;&gt; Current module: {current_module}\")\n                continue\n            if src.upper().startswith(\"IMPORT \"):\n                import_path = src.split(\"IMPORT\", 1)[1].strip().strip('\"')\n                if not import_path.endswith(\".limit\"):\n                    import_path += \".limit\"\n                if import_path in imported_files:\n                    print(f\"[import skipped] &gt;&gt;&gt; Already imported: {import_path}\")\n                    continue\n                try:\n                    with open(import_path, encoding=\"utf-8\") as f:\n                        file_src = f.read()\n                    file_src = normalize_source_with_uimap(file_src, uimap)\n                    lexer = Lexer(CharacterStream(file_src))\n                    file_tokens: list[Token] = []\n                    while True:\n                        tok = lexer.next_token()\n                        if tok.type == \"EOF\":\n                            break\n                        file_tokens.append(tok)\n                    if not file_tokens or any(\n                        tok.type == \"ERROR\" for tok in file_tokens\n                    ):\n                        print(\"[import error] &gt;&gt;&gt; Invalid tokens in file.\")\n                        continue\n                    parsed_ast: list[ASTNode] = Parser(file_tokens).parse()\n                    transpiler = Transpiler(target)\n                    emitter = transpiler.emitter\n                    for node in parsed_ast:\n                        emitter._visit(node)  # type: ignore[attr-defined]\n                    code = emitter.get_output()\n                    if code.strip() and target == \"py\":\n                        exec(code, env_globals)\n                    else:  # pragma: no cover\n                        print(\"[info] transpilation complete\")\n                        print(f\"[warn] Execution not supported for: {target}\")\n                    imported_files.add(import_path)\n                    print(f\"[imported] &gt;&gt;&gt; {import_path}\")\n                except Exception as e:\n                    print(f\"[import error] &gt;&gt;&gt; {e}\")\n                continue\n            src = normalize_source_with_uimap(src, uimap)\n            lexer = Lexer(CharacterStream(src, 0, 1, 1))\n            tokens: list[Token] = []\n            try:\n                while True:\n                    tok = lexer.next_token()\n                    if tok.type == \"EOF\":\n                        break\n                    mapped = (\n                        uimap.get_token(tok.value, tok.line, tok.col)\n                        if tok.type == \"IDENT\"\n                        else None\n                    )\n                    tokens.append(mapped if mapped else tok)\n            except Exception:\n                print_traceback()\n                continue\n\n            if (\n                not tokens\n                or all(t.type == \"EOF\" for t in tokens)\n                or any(t.type == \"ERROR\" for t in tokens)\n            ):\n                print(\"[error] &gt;&gt;&gt;\")\n                print(f\"Invalid token stream: {tokens}\")\n                continue\n\n            parser = Parser(tokens)\n            try:\n                first_type = tokens[0].type\n                if first_type in (\"PLUS\", \"SUB\", \"MULT\", \"DIV\", \"MOD\", \"AND\", \"NOT\"):\n                    parsed_ast = parser.parse_expr_entrypoint()\n                else:\n                    try:\n                        parsed_ast = parser.parse()\n                    except SyntaxError:\n                        try:\n                            parsed_ast = parser.parse_expr_entrypoint()\n                            if parsed_ast == []:\n                                continue\n                        except Exception:\n                            print_traceback()\n                            continue\n                        else:\n                            continue  # fallback succeeded, skip error\n            except Exception:\n                print_traceback()\n                continue\n\n            if not parsed_ast or parsed_ast == []:\n                continue\n\n            try:\n                transpiler = Transpiler(target)\n                emitter = transpiler.emitter\n            except NotImplementedError as e:\n                print(\"[error] &gt;&gt;&gt;\")\n                print(f\"Transpilation error: {e}\")\n                continue\n\n            try:\n                nodes: list[ASTNode]\n                if isinstance(parsed_ast, list):\n                    if parsed_ast and isinstance(parsed_ast[0], list):\n                        # Flatten List[List[ASTNode]] \u2192 List[ASTNode]\n                        flattened: list[Any] = []\n                        for sub in parsed_ast:\n                            if isinstance(sub, list):\n                                flattened.extend(sub)\n                            else:\n                                raise TypeError(\"Expected list of lists of ASTNode\")\n\n                        nodes = flattened\n                    else:\n                        nodes = parsed_ast\n                else:\n                    nodes = [parsed_ast]\n                for node in nodes:\n                    if hasattr(emitter, \"line\" \"s\"):\n                        emitter.lines.clear()\n                    if node.kind in (\n                        \"expr_stmt\",\n                        \"arith\",\n                        \"bool\",\n                        \"compare\",\n                        \"call\",\n                        \"member\",\n                        \"identifier\",\n                        \"float\",\n                        \"number\",\n                        \"string\",\n                        \"new\",\n                    ):\n                        inner = (\n                            node.children[0]\n                            if node.kind == \"expr_stmt\" and node.children\n                            else node\n                        )\n                        result = emitter.emit_expr(inner)  # type: ignore[attr-defined]\n                        if target == \"py\":\n                            try:\n                                if verbose:\n                                    print(f\"[py-expr] &gt;&gt;&gt; {result}\")\n                                exec(f\"_ = {result}\", env_globals)\n                                result_val = env_globals.get(\"_\")\n                                if result_val is not None:\n                                    print(result_val)\n                            except Exception:\n                                print_traceback()\n                        else:  # pragma: no cover\n                            print(\"[info] transpilation complete\")\n                            print(f\"[warn] Execution not supported for: {target}\")\n                        continue\n                    emitter._visit(node)  # type: ignore[attr-defined]\n                    code = emitter.get_output()\n                    if code.strip():  # pragma: no branch\n                        if target == \"py\":\n                            try:\n                                exec(code, env_globals)\n                            except Exception:\n                                print_traceback()\n                        else:\n                            print(\"[info] transpilation complete\")\n                            print(f\"[warn] Execution not supported for: {target}\")\n            except Exception:\n                print_traceback()\n\n        except (KeyboardInterrupt, EOFError):\n            print(\"\\nExiting Limit REPL.\")\n            break\n        except Exception as e:  # pragma: no cover\n            raise RuntimeError(\"Unreachable unless stdout is broken\") from e\n</code></pre>"},{"location":"api/limit_uimap/","title":"UserInterface Mapper","text":"<p>Provides the <code>UserInterfaceMapper</code> class for managing user-defined aliases (\"sugar\") in the LIMIT programming language.</p> <p>This module enables customization of symbolic tokens via alias mappings, allowing developers to configure more human-readable or domain-specific keywords.</p> <p>Classes:</p> Name Description <code>- UserInterfaceMapper</code> <p>Maps user-defined aliases to canonical token types.</p> <code>- MappingError</code> <p>Raised when configuration or alias conflicts occur.</p> Features <ul> <li>Maps alias strings to canonical token types using <code>CANONICAL_TOKENS</code></li> <li>Supports both dict-mode (explicit alias-to-token mapping) and list-mode   (positional mapping against <code>CANONICAL_TOKENS</code>)</li> <li>Detects and reports alias conflicts</li> <li>Loads mappings from JSON configuration files</li> <li>Generates alias reports and session diffs</li> <li>Stores optional descriptions for aliases (used by REPL)</li> </ul> Usage <p>mapper = UserInterfaceMapper.from_canonical() mapper.configure({\"add\": \"PLUS\"}) tok = mapper.get_token(\"add\") print(tok.type)  # \"PLUS\"</p> Note <p>This component is primarily used by the REPL for sugar aliasing, but it can also be used in batch transpilation workflows or UI frontends.</p>"},{"location":"api/limit_uimap/#limit.limit_uimap.MappingError","title":"<code>MappingError(message, conflicts=None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for user alias mapping conflicts in LIMIT.</p> <p>Raised when a user-defined alias configuration is invalid or contains conflicts with existing mappings.</p> <p>Attributes:</p> Name Type Description <code>conflicts</code> <code>list[str]</code> <p>A list of conflicting alias descriptions, typically showing alias name and conflicting token types.</p> Example <p>raise MappingError(\"Alias conflict\", [\"'add' \u2192 PLUS vs MULT\"])</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def __init__(self, message: str, conflicts: list[str] | None = None):\n    super().__init__(message)\n    self.conflicts = conflicts or []\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper","title":"<code>UserInterfaceMapper()</code>","text":"<p>Manages user-defined alias-to-token mappings for the LIMIT language.</p> <p>This class provides functionality for configuring and maintaining symbolic token aliases (also known as \"sugar\") used during lexing and parsing. It supports both dictionary-based and list-based alias configuration modes and provides conflict detection, JSON loading, and reporting utilities.</p> <p>Attributes:</p> Name Type Description <code>token_map</code> <code>dict[str, str]</code> <p>Maps user-defined alias strings to canonical token types.</p> <code>alias_report</code> <code>dict[str, str]</code> <p>A copy of token_map for reporting and summary output.</p> <code>descriptions</code> <code>dict[str, str]</code> <p>Optional descriptions for aliases (used in REPL reporting).</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.token_map: dict[str, str] = {}  # alias \u2192 symbolic token\n    self.alias_report: dict[str, str] = {}  # same, used for reporting\n    self.descriptions: dict[str, str] = {}\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper.configure","title":"<code>configure(cfg)</code>","text":"<p>Applies a new alias-to-token configuration to the mapper.</p> <p>Supports two modes: - Dict mode: maps alias groups (str, list, tuple, set) to a canonical token. - List mode: positional alias groups aligned to <code>CANONICAL_TOKENS</code> by index.</p> <p>Handles duplicate detection and symbolic token validation.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>list[Any] | dict[Any, Any]</code> <p>A configuration object containing alias definitions. - If a dict: maps aliases (or groups of aliases) to symbolic tokens. - If a list: maps positional entries to the token at that index in <code>CANONICAL_TOKENS</code>.</p> required <p>Raises:</p> Type Description <code>MappingError</code> <p>If any of the following occur: - A symbol is not found in <code>CANONICAL_TOKENS</code> - An alias maps to multiple conflicting symbols - The list-mode config exceeds the number of available canonical tokens</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def configure(self, cfg: list[Any] | dict[Any, Any]) -&gt; None:\n    \"\"\"\n    Applies a new alias-to-token configuration to the mapper.\n\n    Supports two modes:\n    - Dict mode: maps alias groups (str, list, tuple, set) to a canonical token.\n    - List mode: positional alias groups aligned to `CANONICAL_TOKENS` by index.\n\n    Handles duplicate detection and symbolic token validation.\n\n    Args:\n        cfg: A configuration object containing alias definitions.\n            - If a dict: maps aliases (or groups of aliases) to symbolic tokens.\n            - If a list: maps positional entries to the token at that index in `CANONICAL_TOKENS`.\n\n    Raises:\n        MappingError: If any of the following occur:\n            - A symbol is not found in `CANONICAL_TOKENS`\n            - An alias maps to multiple conflicting symbols\n            - The list-mode config exceeds the number of available canonical tokens\n    \"\"\"\n    new_token_map: dict[str, str] = {}\n    new_alias_report: dict[str, str] = {}\n    conflicts: list[str] = []\n\n    valid_symbols = set(CANONICAL_TOKENS)\n\n    if isinstance(cfg, dict):\n        for alias_group, sym in cfg.items():\n            if sym not in valid_symbols:\n                raise MappingError(f\"Unknown symbolic token name: {sym}\")\n            for alias in self._extract_aliases(alias_group):\n                if (alias in self.token_map and self.token_map[alias] != sym) or (\n                    alias in new_token_map and new_token_map[alias] != sym\n                ):\n                    conflicts.append(\n                        f\"'{alias}' \u2192 conflict between {self.token_map.get(alias)} and {sym}\"\n                    )\n                else:\n                    new_token_map[alias] = sym\n                    new_alias_report[alias] = sym\n\n    elif isinstance(cfg, list):\n        if len(cfg) &gt; len(CANONICAL_TOKENS):\n            raise MappingError(\"Too many entries in list-mode config\")\n        for idx, entry in enumerate(cfg):\n            sym = CANONICAL_TOKENS[idx]\n            for alias in self._extract_aliases(entry):\n                if (alias in self.token_map and self.token_map[alias] != sym) or (\n                    alias in new_token_map and new_token_map[alias] != sym\n                ):\n                    conflicts.append(\n                        f\"'{alias}' \u2192 conflict between {self.token_map.get(alias)} and {sym}\"\n                    )\n                else:\n                    new_token_map[alias] = sym\n                    new_alias_report[alias] = sym\n    else:\n        raise MappingError(\"Configuration must be either a list or a dict\")\n\n    if conflicts:\n        raise MappingError(\"Alias collision(s) detected\", conflicts)\n\n    self.token_map.update(new_token_map)\n    self.alias_report.update(new_alias_report)\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper.from_canonical","title":"<code>from_canonical()</code>  <code>classmethod</code>","text":"<p>Constructs a <code>UserInterfaceMapper</code> preloaded with the default canonical aliases.</p> <p>Uses <code>CANONICAL_TOKEN_MAP</code> to build a lowercase mapping of aliases to symbolic tokens.</p> <p>Returns:</p> Type Description <code>UserInterfaceMapper</code> <p>A configured <code>UserInterfaceMapper</code> instance with canonical mappings applied.</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>@classmethod\ndef from_canonical(cls) -&gt; \"UserInterfaceMapper\":\n    \"\"\"\n    Constructs a `UserInterfaceMapper` preloaded with the default canonical aliases.\n\n    Uses `CANONICAL_TOKEN_MAP` to build a lowercase mapping of aliases to symbolic tokens.\n\n    Returns:\n        A configured `UserInterfaceMapper` instance with canonical mappings applied.\n    \"\"\"\n    instance = cls()\n    canonical_aliases: dict[str, str] = {\n        key.lower(): value\n        for key, value in CANONICAL_TOKEN_MAP.items()\n        if isinstance(key, str) and isinstance(value, str)\n    }\n    instance.configure(canonical_aliases)\n    return instance\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper.get_token","title":"<code>get_token(alias, line=0, col=0)</code>","text":"<p>Resolves an alias to a Token if it exists in the current alias map.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The user-defined alias string.</p> required <code>line</code> <code>int</code> <p>Line number to attach to the token (optional).</p> <code>0</code> <code>col</code> <code>int</code> <p>Column number to attach to the token (optional).</p> <code>0</code> <p>Returns:</p> Type Description <code>Token | None</code> <p>A <code>Token</code> with the resolved symbolic type if the alias exists, else <code>None</code>.</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def get_token(self, alias: str, line: int = 0, col: int = 0) -&gt; Token | None:\n    \"\"\"Resolves an alias to a Token if it exists in the current alias map.\n\n    Args:\n        alias: The user-defined alias string.\n        line: Line number to attach to the token (optional).\n        col: Column number to attach to the token (optional).\n\n    Returns:\n        A `Token` with the resolved symbolic type if the alias exists, else `None`.\n    \"\"\"\n    sym = self.token_map.get(alias)\n    return Token(sym, alias, line, col) if sym else None\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper.load_from_json","title":"<code>load_from_json(path)</code>","text":"<p>Loads alias-to-token mappings from a JSON file and applies them via <code>configure</code>.</p> <p>The JSON file should contain a dictionary where each key is a string of comma-separated aliases and each value is a canonical token type. Keys are automatically split into multiple aliases.</p> Example JSON structure <p>{     \"plus,add,+\": \"PLUS\",     \"sub,-\": \"SUB\" }</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the JSON file containing alias mappings.</p> required <p>Raises:</p> Type Description <code>MappingError</code> <p>If the file cannot be loaded or the configuration is invalid.</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def load_from_json(self, path: str) -&gt; None:\n    \"\"\"\n    Loads alias-to-token mappings from a JSON file and applies them via `configure`.\n\n    The JSON file should contain a dictionary where each key is a string of comma-separated\n    aliases and each value is a canonical token type. Keys are automatically split into\n    multiple aliases.\n\n    Example JSON structure:\n        {\n            \"plus,add,+\": \"PLUS\",\n            \"sub,-\": \"SUB\"\n        }\n\n    Args:\n        path: Path to the JSON file containing alias mappings.\n\n    Raises:\n        MappingError: If the file cannot be loaded or the configuration is invalid.\n    \"\"\"\n    try:\n        with open(path, encoding=\"utf-8\") as f:\n            raw_cfg = json.load(f)\n\n        parsed_cfg: dict[tuple[Any, ...], str] = {}\n        for key, value in raw_cfg.items():\n            aliases = [alias.strip() for alias in key.split(\",\")]\n            parsed_cfg[tuple(aliases)] = value\n\n        self.configure(parsed_cfg)\n\n    except Exception as e:\n        raise MappingError(f\"Failed to load sugar file: {e}\") from e\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper.report","title":"<code>report(verbose=False)</code>","text":"<p>Generates a formatted string report of the current alias mappings.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, includes token slot index information for each mapping.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A newline-separated string summarizing alias \u2192 token relationships.</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def report(self, verbose: bool = False) -&gt; str:\n    \"\"\"Generates a formatted string report of the current alias mappings.\n\n    Args:\n        verbose: If True, includes token slot index information for each mapping.\n\n    Returns:\n        A newline-separated string summarizing alias \u2192 token relationships.\n    \"\"\"\n    lines: list[str] = []\n    for alias, sym in sorted(self.alias_report.items()):\n        if verbose:\n            idx = CANONICAL_TOKENS.index(sym)\n            lines.append(f\"{alias:&gt;12} \u2192 {sym:&lt;16} (slot {idx})\")\n        else:\n            lines.append(f\"{alias:&gt;12} \u2192 {sym}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/limit_uimap/#limit.limit_uimap.UserInterfaceMapper.summary","title":"<code>summary()</code>","text":"<p>Returns a copy of the current alias mapping.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary mapping alias strings to symbolic token types.</p> Source code in <code>src/limit/limit_uimap.py</code> <pre><code>def summary(self) -&gt; dict[str, str]:\n    \"\"\"Returns a copy of the current alias mapping.\n\n    Returns:\n        A dictionary mapping alias strings to symbolic token types.\n    \"\"\"\n    return dict(self.alias_report)\n</code></pre>"}]}